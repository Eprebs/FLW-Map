<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HuntAO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#151a1e" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="Circle.svg" type="image/svg+xml" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Montserrat:wght@600;700&display=swap" rel="stylesheet" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <!-- Leaflet Routing Machine CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css"
  />

  <style>
    :root {
      --obsidian: #151a1e;
      --obsidian-2: #1a2025;
      --forest: #1f3a31;
      --forest-2: #2a4a40;
      --blaze: #ff6a1a;
      --blaze-strong: #ff7f36;
      --slate: #9ba7b1;
      --slate-muted: #7f8b95;
      --text: #ecf2f0;
      --border: rgba(160, 180, 194, 0.24);
      --glass-bg: rgba(24, 33, 40, 0.72);
      --glass-strong: rgba(21, 29, 36, 0.84);
      --ring: rgba(255, 106, 26, 0.46);
      --topo-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='420' height='220' viewBox='0 0 420 220'%3E%3Cg fill='none' stroke='%23AFC0CF22' stroke-width='1'%3E%3Cpath d='M-30 30 C 20 10, 72 10, 122 30 C 170 50, 220 50, 270 30 C 320 10, 372 10, 430 30'/%3E%3Cpath d='M-30 46 C 20 26, 72 26, 122 46 C 170 66, 220 66, 270 46 C 320 26, 372 26, 430 46'/%3E%3Cpath d='M-30 66 C 10 50, 48 48, 86 62 C 124 76, 164 80, 204 68 C 246 56, 288 58, 330 72 C 366 84, 398 82, 430 72'/%3E%3Cpath d='M-30 82 C 10 66, 48 64, 86 78 C 124 92, 164 96, 204 84 C 246 72, 288 74, 330 88 C 366 100, 398 98, 430 88'/%3E%3Cpath d='M-30 108 C 18 82, 62 80, 106 98 C 150 116, 194 120, 240 102 C 286 84, 330 86, 374 106 C 394 114, 412 116, 430 112'/%3E%3Cpath d='M-30 126 C 18 100, 62 98, 106 116 C 150 134, 194 138, 240 120 C 286 102, 330 104, 374 124 C 394 132, 412 134, 430 130'/%3E%3Cpath d='M-30 154 C 16 136, 56 140, 96 158 C 136 176, 180 182, 224 170 C 268 158, 312 158, 354 174 C 382 184, 406 186, 430 182'/%3E%3Cpath d='M-30 172 C 16 154, 56 158, 96 176 C 136 194, 180 200, 224 188 C 268 176, 312 176, 354 192 C 382 202, 406 204, 430 200'/%3E%3Cpath d='M-30 198 C 20 176, 68 170, 116 186 C 164 202, 212 206, 260 192 C 308 178, 356 180, 430 204'/%3E%3C/g%3E%3C/svg%3E");

      --ink: var(--obsidian);
      --panel: var(--obsidian-2);
      --panel-strong: var(--glass-strong);
      --panel-overlay: var(--glass-bg);
      --muted: var(--slate);
      --gold: var(--blaze);
      --gold-strong: var(--blaze-strong);
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top right, #1b242a 0%, var(--obsidian) 48%, #11161a 100%);
      color: var(--text);
    }

    h2, h3, h4 {
      font-family: "Montserrat", "Inter", system-ui, sans-serif;
      letter-spacing: 0.01em;
    }

    #map {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    /* Drawer */
    #drawerToggle {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1001;
      background: var(--glass-strong);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 13px;
      backdrop-filter: blur(7px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.34);
    }

    #drawer {
      position: fixed;
      top: 0;
      left: 0;
      width: 280px;
      max-width: 80%;
      height: 100%;
      background: linear-gradient(165deg, rgba(22, 31, 38, 0.95) 0%, rgba(20, 28, 35, 0.9) 100%);
      background-image: var(--topo-pattern), linear-gradient(165deg, rgba(22, 31, 38, 0.95) 0%, rgba(20, 28, 35, 0.9) 100%);
      background-size: 420px auto, cover;
      color: var(--text);
      z-index: 1000;
      transform: translateX(-100%);
      transition: transform 0.25s ease-out;
      padding: 8px 10px 20px 10px;
      box-sizing: border-box;
      overflow-y: auto;
      border-right: 1px solid var(--border);
      backdrop-filter: blur(8px);
    }

    #drawer.open {
      transform: translateX(0);
    }

    #drawer h2 {
      margin: 0 0 8px 0;
      font-size: 18px;
    }

    #drawer h3 {
      margin: 10px 0 4px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--slate);
    }

    .drawer-section {
      margin-bottom: 8px;
    }

    .drawer-brand {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 2px 0 8px 0;
    }

    .drawer-brand img {
      max-width: 116px;
      height: auto;
      opacity: 0.95;
    }

    .drawer-btn {
      width: 100%;
      padding: 10px;
      margin: 4px 0;
      background: linear-gradient(180deg, rgba(36, 62, 53, 0.92), rgba(28, 49, 42, 0.92));
      color: var(--text);
      border: 1px solid rgba(124, 151, 167, 0.35);
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      backdrop-filter: blur(4px);
      transition: transform 0.12s ease, border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    .drawer-btn:hover {
      border-color: rgba(166, 190, 204, 0.42);
      transform: translateY(-1px);
    }

    .drawer-btn.active {
      background: linear-gradient(180deg, var(--blaze-strong), var(--blaze));
      color: #111111;
      border-color: rgba(255, 194, 160, 0.65);
      box-shadow: 0 0 0 2px rgba(255, 106, 26, 0.2);
    }

    .drawer-label {
      display: block;
      margin: 4px 0;
      font-size: 13px;
    }

    #startTrackBtn,
    #addWaypointBtn,
    #submitReportBtn,
    #startDownloadBtn,
    #loginBtn,
    .modal-btn.primary {
      background: linear-gradient(180deg, var(--blaze-strong), var(--blaze));
      color: #101010;
      border: 1px solid rgba(255, 198, 168, 0.7);
    }

    #startTrackBtn:hover,
    #addWaypointBtn:hover,
    #submitReportBtn:hover,
    #startDownloadBtn:hover,
    #loginBtn:hover,
    .modal-btn.primary:hover {
      box-shadow: 0 0 0 2px rgba(255, 106, 26, 0.24);
    }

    .drawer-label input[type="checkbox"],
    .drawer-label input[type="radio"] {
      margin-right: 6px;
      accent-color: var(--blaze-strong);
      cursor: pointer;
    }

    input[type="checkbox"],
    input[type="radio"] {
      accent-color: var(--blaze-strong);
    }

    button,
    input[type="button"],
    input[type="submit"] {
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text);
    }

    .drawer-info {
      font-size: 12px;
      color: var(--slate);
      margin-top: 4px;
    }

    input[type="number"], input[type="text"] {
      width: 100%;
      padding: 4px;
      margin-top: 2px;
      border-radius: 4px;
      border: 1px solid rgba(127, 148, 163, 0.35);
      background: rgba(17, 25, 31, 0.7);
      color: var(--text);
      font-size: 13px;
      box-sizing: border-box;
    }

    select {
      width: 100%;
      margin-top: 4px;
      min-height: 38px;
      padding: 8px 34px 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(127, 148, 163, 0.42);
      background-color: rgba(15, 23, 29, 0.88);
      color: var(--text);
      font-size: 13px;
      font-weight: 600;
      box-sizing: border-box;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image:
        linear-gradient(to bottom, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.01)),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12'%3E%3Cpath fill='%23ff7f36' d='M1.6 3.4a.9.9 0 0 1 1.27 0L6 6.52 9.13 3.4a.9.9 0 1 1 1.27 1.27L6.64 8.43a.9.9 0 0 1-1.27 0L1.6 4.67a.9.9 0 0 1 0-1.27z'/%3E%3C/svg%3E");
      background-repeat: no-repeat, no-repeat;
      background-position: 0 0, right 10px center;
      background-size: auto, 12px 12px;
      transition: border-color 0.18s ease, box-shadow 0.18s ease;
    }

    select:focus {
      outline: none;
      border-color: rgba(255, 127, 54, 0.72);
      box-shadow: 0 0 0 2px rgba(255, 106, 26, 0.22);
    }

    select option {
      background: #172129;
      color: var(--text);
    }

    /* HUD bottom-right */
    #hud {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 1001;
      background: var(--glass-strong);
      background-image: var(--topo-pattern);
      background-size: 340px auto;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      max-width: 260px;
      border: 1px solid var(--border);
      backdrop-filter: blur(7px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.28);
    }

    #hud div {
      margin: 2px 0;
    }

    /* Top-right controls */
    #topRightControls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1001;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .control-btn {
      background: var(--glass-strong);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px 8px;
      cursor: pointer;
      font-size: 12px;
      backdrop-filter: blur(7px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.24);
    }

    .control-btn.active {
      background: linear-gradient(180deg, var(--blaze-strong), var(--blaze));
      color: #111111;
    }

    /* Offline indicator */
    #offlineIndicator {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 1001;
      background: var(--glass-strong);
      color: var(--text);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 12px;
      display: none;
      border: 1px solid var(--border);
      backdrop-filter: blur(7px);
    }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .modal {
      background: var(--glass-strong);
      background-image: var(--topo-pattern);
      background-size: 340px auto;
      border-radius: 12px;
      padding: 16px;
      max-width: 360px;
      width: 90%;
      color: var(--text);
      border: 1px solid var(--border);
      box-shadow: 0 14px 34px rgba(0, 0, 0, 0.5);
      font-size: 14px;
      backdrop-filter: blur(10px);
    }

    .modal h3 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 16px;
    }

    .modal-buttons {
      margin-top: 12px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .modal-btn {
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 13px;
    }

    .modal-btn.primary {
      background: var(--gold);
      color: #111111;
    }

    .modal-btn.secondary {
      background: rgba(42, 57, 68, 0.82);
      color: var(--text);
      border: 1px solid rgba(148, 169, 184, 0.3);
    }

    .auth-modal {
      max-width: 420px;
      width: 92%;
      max-height: 84vh;
      overflow-y: auto;
      padding: 20px;
      border-radius: 14px;
    }

    .auth-modal-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 20px;
      letter-spacing: 0.01em;
    }

    .auth-subtitle {
      font-size: 12px;
      color: var(--slate-muted);
      margin: 0 0 14px 0;
      line-height: 1.45;
    }

    .auth-field {
      display: block;
      margin-bottom: 12px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .auth-field input {
      margin-top: 6px;
      min-height: 40px;
      padding: 10px 11px;
      border-radius: 10px;
      border: 1px solid rgba(136, 158, 173, 0.34);
      background: rgba(15, 23, 29, 0.78);
      transition: border-color 0.18s ease, box-shadow 0.18s ease;
    }

    .auth-field input:focus {
      outline: none;
      border-color: rgba(255, 127, 54, 0.72);
      box-shadow: 0 0 0 2px rgba(255, 106, 26, 0.2);
    }

    .auth-note {
      font-size: 12px;
      color: var(--slate-muted);
      margin: 10px 0 12px 0;
      line-height: 1.4;
    }

    #liabilityGate {
      position: fixed;
      inset: 0;
      background: rgba(6, 10, 13, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5000;
      padding: 14px;
      box-sizing: border-box;
    }

    .liability-card {
      width: min(680px, 96vw);
      max-height: 90vh;
      overflow-y: auto;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: var(--glass-strong);
      background-image: var(--topo-pattern);
      background-size: 420px auto;
      padding: 18px;
      box-shadow: 0 18px 46px rgba(0, 0, 0, 0.56);
    }

    .liability-title {
      margin: 0 0 8px 0;
      font-size: 20px;
      color: var(--gold-strong);
    }

    .liability-text {
      margin: 0 0 10px 0;
      font-size: 13px;
      color: var(--text);
      line-height: 1.52;
    }

    .liability-list {
      margin: 0 0 12px 18px;
      padding: 0;
      font-size: 13px;
      color: var(--text);
      line-height: 1.52;
    }

    .liability-list li {
      margin: 0 0 6px 0;
    }

    .liability-ack {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-top: 10px;
      font-size: 13px;
      color: var(--text);
      line-height: 1.45;
    }

    .liability-ack input {
      margin-top: 2px;
      accent-color: var(--blaze-strong);
    }

    .liability-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    #liabilityAgreeBtn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }

    #liabilityDeclineNote {
      margin-top: 8px;
      font-size: 12px;
      color: var(--slate-muted);
      min-height: 16px;
    }

    .auth-row {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .auth-row .drawer-btn,
    .auth-row .modal-btn {
      flex: 1;
      min-height: 38px;
    }

    .auth-modal .drawer-btn {
      min-height: 42px;
      margin-top: 2px;
      font-size: 13px;
    }

    /* Activity Forecast Modal */
    #activityModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    #activityModal.open {
      display: flex;
    }

    #activityPanel {
      background: var(--glass-strong);
      background-image: var(--topo-pattern);
      background-size: 380px auto;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      max-width: 420px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      backdrop-filter: blur(10px);
    }

    #activityPanel h3 {
      margin: 0 0 16px 0;
      font-size: 18px;
      color: var(--gold-strong);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #activityPanel .close-btn {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 20px;
      padding: 0;
      line-height: 1;
    }

    #activityPanel .close-btn:hover {
      color: var(--gold);
    }

    #activityPanel .forecast-section {
      margin: 16px 0;
      padding: 12px;
      background: rgba(16, 27, 34, 0.62);
      border-radius: 10px;
      border: 1px solid rgba(132, 153, 168, 0.28);
      border-left: 3px solid var(--blaze);
    }

    #activityPanel .forecast-section h4 {
      margin: 0 0 8px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--gold);
    }

    #activityPanel .forecast-item {
      margin: 8px 0;
      padding: 8px;
      background: rgba(12, 20, 25, 0.48);
      border-radius: 8px;
      border: 1px solid rgba(120, 142, 156, 0.26);
      border-left: 2px solid var(--blaze-strong);
    }

    #activityPanel .forecast-item p {
      margin: 0;
      font-size: 13px;
      line-height: 1.5;
    }

    #activityPanel .activity-level {
      font-size: 14px;
      font-weight: bold;
      color: var(--gold-strong);
      margin: 12px 0;
    }

    #activityPanel .tip {
      font-size: 12px;
      line-height: 1.6;
      color: var(--text);
    }

    #weatherModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    #weatherModal.open {
      display: flex;
    }

    #weatherPanel {
      background: var(--glass-strong);
      background-image: var(--topo-pattern);
      background-size: 380px auto;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      backdrop-filter: blur(10px);
    }

    #weatherPanel h3 {
      margin: 0 0 16px 0;
      font-size: 18px;
      color: var(--gold-strong);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #weatherPanel .close-btn {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 20px;
      padding: 0;
      line-height: 1;
    }

    #weatherPanel .close-btn:hover {
      color: var(--gold);
    }

    #weatherPanel .weather-section {
      margin: 16px 0;
      padding: 12px;
      background: rgba(16, 27, 34, 0.62);
      border-radius: 10px;
      border: 1px solid rgba(132, 153, 168, 0.28);
      border-left: 3px solid var(--blaze);
    }

    #weatherPanel .weather-section h4 {
      margin: 0 0 8px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--gold);
    }

    #weatherPanel .weather-item {
      display: flex;
      justify-content: space-between;
      margin: 6px 0;
      font-size: 13px;
      line-height: 1.4;
    }

    #weatherPanel .weather-item strong {
      color: #d3dde3;
      flex: 0 0 auto;
      font-weight: 600;
    }

    #weatherPanel .weather-item span {
      flex: 1;
      text-align: right;
    }

    #weatherPanel .last-updated {
      font-size: 11px;
      color: var(--muted);
      margin-top: 16px;
      text-align: center;
    }

    #weatherPanel .loading {
      text-align: center;
      color: var(--muted);
      padding: 20px;
    }

    /* Area legend */
    #areaLegend {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1001;
      background: var(--glass-strong);
      background-image: var(--topo-pattern);
      background-size: 260px auto;
      color: var(--text);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 11px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      border: 1px solid var(--border);
      backdrop-filter: blur(6px);
    }

    /* Leaflet popups */
    .leaflet-popup-content-wrapper {
      background: rgba(17, 26, 33, 0.92) !important;
      background-image: var(--topo-pattern) !important;
      background-size: 280px auto !important;
      color: var(--text) !important;
      border: 1px solid rgba(255, 142, 72, 0.62) !important;
      border-radius: 10px;
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.45);
    }

    .leaflet-popup-tip {
      background: rgba(17, 26, 33, 0.92) !important;
      border: 1px solid rgba(255, 142, 72, 0.62) !important;
    }

    .leaflet-popup-content {
      margin: 10px 12px;
      font-size: 13px;
      line-height: 1.3;
    }

    .leaflet-popup-content strong {
      color: var(--gold-strong);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #111827;
    }

    .legend-swatch.hatch {
      background-image: repeating-linear-gradient(
        45deg,
        rgba(249, 115, 22, 0.8),
        rgba(249, 115, 22, 0.8) 2px,
        transparent 2px,
        transparent 4px
      );
      background-color: transparent;
    }

    .legend-swatch.dots {
      background-image: radial-gradient(circle, rgba(59, 130, 246, 0.9) 1px, transparent 1px);
      background-size: 6px 6px;
      background-color: transparent;
    }

    /* Small screens */
    @media (max-width: 600px) {
      #hud {
        max-width: 200px;
        font-size: 11px;
      }
      #aiPanel {
        top: 80px;
        max-width: 220px;
      }
      #areaLegend {
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <button id="drawerToggle">â˜°</button>

  <div id="drawer">
    <div class="drawer-brand">
      <img src="Logo2.png" alt="HuntAO">
    </div>

    <h3>Layers</h3>
    <div class="drawer-section">
      <label class="drawer-label">
        <input type="radio" name="basemap" value="satellite" checked>
        Satellite (ESRI)
      </label>
      <label class="drawer-label">
        <input type="radio" name="basemap" value="osm">
        Streets (OSM)
      </label>
      <label class="drawer-label">
        <input type="radio" name="basemap" value="usgs">
        USGS Topo
      </label>
      <label class="drawer-label">
        <input type="radio" name="basemap" value="esri">
        ESRI Topo
      </label>
      <label class="drawer-label">
        <input type="radio" name="basemap" value="otm">
        OpenTopoMap
      </label>
    </div>

    <h3>Terrain Overlays</h3>
    <div class="drawer-section">
      <label class="drawer-label">
        <input type="checkbox" id="contoursToggle">
        Contours
      </label>
      <label class="drawer-label">
        <input type="checkbox" id="hillshadeToggle">
        Hillshade
      </label>
    </div>

    <h3>Offline Maps</h3>
    <div class="drawer-section">
      <button id="downloadOfflineBtn" class="drawer-btn">
        Download Offline Area
      </button>

      <label class="drawer-label">
        <input type="checkbox" id="includeSatelliteToggle">
        Include Satellite Tiles
      </label>

      <label class="drawer-label">
        Zoom Levels:
        <select id="offlineZoomSelect">
          <option value="12-16">12â€“16 (Fast, small)</option>
          <option value="12-17" selected>12â€“17 (Recommended)</option>
          <option value="13-17">13â€“17 (High detail)</option>
        </select>
      </label>

      <div id="offlineStorageUsage" class="drawer-info">
        Storage Used: calculatingâ€¦
      </div>
    </div>

    <h3>Tools</h3>
    <div class="drawer-section">
      <button id="gpsFollowBtn" class="drawer-btn">Snap to My Location</button>
      <button id="addWaypointBtn" class="drawer-btn">Add Waypoint</button>
      <button id="startTrackBtn" class="drawer-btn">Start Track</button>
      <button id="measureBtn" class="drawer-btn">Measure Distance</button>
      <button id="routingBtn" class="drawer-btn">Routing</button>
      <button id="clearRoutesBtn" class="drawer-btn">Clear Routes/Tracks</button>
    </div>

    <h3>Account & Sync</h3>
    <div class="drawer-section">
      <div id="authStatus" class="drawer-info" style="margin-bottom: 8px;">Not signed in</div>
      <div id="syncStatus" class="drawer-info" style="margin-bottom: 8px;">Sync status: idle</div>
      <button id="openAccountModalBtn" class="drawer-btn">Open Account & Sync</button>
    </div>

    <h3>Status & Info</h3>
    <div class="drawer-section">
      <button id="refreshStatusBtn" class="drawer-btn">Refresh Area Status</button>
      <div id="statusSummary" class="drawer-info">
        Status: not loaded yet.
      </div>
      <div id="statusCounts" class="drawer-info">
        Open: --, Closed: --, Signed in: --
      </div>
    </div>

    <h3>Bases</h3>
    <div class="drawer-section">
      <label class="drawer-label">
        Select Base
        <select id="baseSelect">
          <option value="fort_leonard_wood" selected>Fort Leonard Wood</option>
        </select>
      </label>
    </div>
  </div>

  <div id="hud">
    <div id="hudLocation">Lat: ---, Lng: ---</div>
    <div id="hudAccuracy">Accuracy: ---</div>
    <div id="hudCurrentArea">Area: ---</div>
    <div id="hudTime">Time: ---</div>
    <div id="hudWeather">Weather: loadingâ€¦</div>
  </div>

  <div id="topRightControls">
    <button id="stealthModeBtn" class="control-btn">Stealth</button>
    <button id="weatherBtn" class="control-btn">Weather</button>
    <button id="activityForecastBtn" class="control-btn">Activity</button>
    <button id="reportProblemBtn" class="control-btn">Report Problem</button>
  </div>

  <div id="offlineIndicator">ðŸ“¦ Offline Map Available</div>

  <div id="liabilityGate" role="dialog" aria-modal="true" aria-labelledby="liabilityTitle">
    <div class="liability-card">
      <h2 id="liabilityTitle" class="liability-title">Boundary & Liability Acknowledgment Required</h2>
      <p class="liability-text">This app provides boundary and area status information as a guide only. Boundaries, overlays, and status updates may have inaccuracies, delays, or GPS drift. You are solely responsible for confirming where you are and whether your intended area is legally open before signing in.</p>
      <ul class="liability-list">
        <li>If you are near a boundary, verify both neighboring areas directly from official sources and posted signs before checking in.</li>
        <li>If you are on or crossing a boundary edge, ensure both areas are open and sign into both areas as required by local/installation rules.</li>
        <li>Do not rely on this app as the sole authority for legal access, boundaries, or compliance decisions.</li>
        <li>By continuing, you accept full responsibility for your own location, sign-in actions, and legal compliance, and you release HuntAO and its operators from liability related to boundary/sign-in errors or resulting citations.</li>
      </ul>
      <label class="liability-ack" for="liabilityAcknowledge">
        <input id="liabilityAcknowledge" type="checkbox">
        <span>I understand and agree to the Boundary & Liability Acknowledgment above.</span>
      </label>
      <div class="liability-actions">
        <button id="liabilityAgreeBtn" class="drawer-btn" disabled>I Agree â€” Enter App</button>
        <button id="liabilityDeclineBtn" class="modal-btn secondary">I Do Not Agree</button>
      </div>
      <div id="liabilityDeclineNote"></div>
    </div>
  </div>

  <div id="activityModal">
    <div id="activityPanel">
      <h3>
        Deer Activity Forecast
        <button class="close-btn" id="activityPanelClose">âœ•</button>
      </h3>
      <div id="activityContent">
        <div style="text-align: center; color: var(--muted); padding: 20px;">Open weather first to generate forecast</div>
      </div>
    </div>
  </div>

  <div id="weatherModal">
    <div id="weatherPanel">
      <h3>
        Local Weather
        <button class="close-btn" id="weatherPanelClose">âœ•</button>
      </h3>
      <div id="weatherContent">
        <div class="loading">Fetching weather data...</div>
      </div>
    </div>
  </div>

  <div id="reportProblemModal" style="position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; z-index: 2100; align-items: center; justify-content: center;">
    <div style="background: var(--panel-strong); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 20px; width: 92%; max-width: 520px;">
      <h3 style="margin: 0 0 12px 0; color: var(--gold-strong);">Report a Problem</h3>
      <label style="display:block; font-size: 13px; color: var(--muted); margin-bottom: 6px;">Your Email (optional)</label>
      <input id="reportContactEmail" type="text" placeholder="you@example.com" style="width:100%; padding:8px; margin-bottom:10px; border-radius:4px; border:1px solid var(--border); background: var(--panel); color: var(--text); box-sizing: border-box;" />
      <label style="display:block; font-size: 13px; color: var(--muted); margin-bottom: 6px;">What happened?</label>
      <textarea id="reportMessage" rows="6" placeholder="Describe the bug, what you expected, and what happened..." style="width:100%; padding:8px; border-radius:4px; border:1px solid var(--border); background: var(--panel); color: var(--text); box-sizing: border-box; resize: vertical;"></textarea>
      <div style="display:flex; gap:8px; margin-top: 12px;">
        <button id="cancelReportBtn" class="modal-btn secondary" style="flex:1;">Cancel</button>
        <button id="submitReportBtn" class="modal-btn primary" style="flex:1;">Submit</button>
      </div>
    </div>
  </div>

  <div id="accountModalBackdrop" class="modal-backdrop">
    <div class="modal auth-modal">
      <h3 class="auth-modal-title">
        Account
        <button id="accountModalClose" class="modal-btn secondary" style="padding: 4px 8px;">âœ•</button>
      </h3>
      <p id="authModalSubtitle" class="auth-subtitle">Access your synced waypoints and tracks.</p>

      <div id="signedOutAccountSection">
        <label class="auth-field">
          Username
          <input id="authEmailInput" type="text" placeholder="you@example.com" autocomplete="email">
        </label>

        <label class="auth-field">
          Password
          <input id="authPasswordInput" type="password" placeholder="Enter password" autocomplete="current-password">
        </label>

        <button id="loginBtn" class="drawer-btn">Log In</button>

        <div class="auth-row">
          <button id="requestResetBtn" class="modal-btn secondary">Reset Password</button>
          <button id="openSignupModalBtn" class="modal-btn secondary">Create Account</button>
        </div>

        <div class="auth-note">Use your email as username. Reset sends a secure link to your email.</div>
      </div>

      <div id="signedInAccountSection" style="display: none;">
        <div class="auth-note" style="margin-top: 0;">Signed in as <strong id="signedInEmailLabel"></strong></div>
        <div class="auth-row" style="margin-top: 0;">
          <button id="requestResetSignedInBtn" class="modal-btn secondary">Reset Password</button>
          <button id="logoutBtn" class="modal-btn secondary">Logout</button>
        </div>
        <div class="auth-row">
          <button id="manageOfflineBtn" class="modal-btn secondary">Manage Offline Packs</button>
          <button id="syncNowBtn" class="modal-btn secondary">Sync Now</button>
        </div>
      </div>

      <div id="resetPasswordPanel" style="display: none; margin-top: 8px;">
        <label class="auth-field">
          Reset Token
          <input id="resetTokenInput" type="text" placeholder="Paste reset token from email link">
        </label>

        <label class="auth-field">
          New Password
          <input id="newPasswordInput" type="password" placeholder="Set new password">
        </label>
        <button id="resetPasswordBtn" class="drawer-btn">Set New Password</button>
      </div>

      <input id="profileFullName" type="hidden" value="">
      <input id="profilePhone" type="hidden" value="">
      <input id="profileVehicle" type="hidden" value="">
      <input id="profileEmergencyContact" type="hidden" value="">
      <input id="profileNotes" type="hidden" value="">
    </div>
  </div>

  <div id="signupModalBackdrop" class="modal-backdrop">
    <div class="modal auth-modal">
      <h3 class="auth-modal-title">
        Create Account
        <button id="signupModalClose" class="modal-btn secondary" style="padding: 4px 8px;">âœ•</button>
      </h3>
      <p class="auth-subtitle">Set up your account for secure sync across devices.</p>

      <label class="auth-field">
        Full Name
        <input id="signupFullNameInput" type="text" placeholder="Your name" autocomplete="name">
      </label>

      <label class="auth-field">
        Email
        <input id="signupEmailInput" type="text" placeholder="you@example.com" autocomplete="email">
      </label>

      <label class="auth-field">
        Password
        <input id="signupPasswordInput" type="password" placeholder="At least 8 characters" autocomplete="new-password">
      </label>

      <button id="signupBtn" class="drawer-btn">Create Account</button>

      <div class="auth-row">
        <button id="switchToLoginBtn" class="modal-btn secondary">Back to Login</button>
      </div>
    </div>
  </div>

  <div id="offlineDownloadModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; z-index: 2000; justify-content: center; align-items: center;">
    <div style="background: var(--panel-strong); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 20px; max-width: 400px; width: 90%;">
      <h3 style="margin: 0 0 16px 0; color: var(--gold-strong);">Download Offline Maps</h3>
      <label style="display: block; margin: 12px 0; font-size: 13px;">
        <strong>Zoom Level:</strong>
        <select id="offlineZoomLevelSelect" style="width: 100%; padding: 6px; margin-top: 4px; border-radius: 4px; border: 1px solid var(--border); background: var(--panel); color: var(--text);">
          <option value="15">Zoom 15 (High detail, ~100MB)</option>
          <option value="14">Zoom 14 (Balanced, ~25MB)</option>
          <option value="13">Zoom 13 (Lower detail, ~6MB)</option>
          <option value="12">Zoom 12 (Minimal, ~2MB)</option>
        </select>
      </label>
      <label style="display: block; margin: 12px 0; font-size: 13px;">
        <input type="checkbox" id="downloadSatCheckbox" checked> Include Satellite Imagery
      </label>
      <div id="downloadProgress" style="display: none; margin: 12px 0;">
        <div style="font-size: 12px; margin-bottom: 6px;">Downloading: <span id="downloadStatus">0/0</span></div>
        <div style="width: 100%; height: 20px; background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;">
          <div id="downloadProgressBar" style="width: 0%; height: 100%; background: var(--gold-strong); transition: width 0.2s;"></div>
        </div>
      </div>
      <div style="display: flex; gap: 8px; margin-top: 16px;">
        <button onclick="document.getElementById('offlineDownloadModal').style.display='none'" class="modal-btn secondary" style="flex: 1;">Cancel</button>
        <button id="startDownloadBtn" class="modal-btn primary" style="flex: 1;">Start Download</button>
      </div>
    </div>
  </div>

  <div id="offlineManageModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; z-index: 2000; justify-content: center; align-items: center;">
    <div style="background: var(--panel-strong); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 20px; max-width: 450px; width: 90%; max-height: 80vh; overflow-y: auto;">
      <h3 style="margin: 0 0 16px 0; color: var(--gold-strong);">Manage Offline Packs</h3>
      <div id="storageUsageContainer">
        <p style="font-size: 12px; color: var(--muted); margin: 8px 0;">
          Storage Used: <strong id="storageSizeDisplay">0 MB</strong> / 5 GB
        </p>
        <div style="width: 100%; height: 12px; background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden; margin-bottom: 16px;">
          <div id="storageBar" style="width: 0%; height: 100%; background: var(--gold-strong);"></div>
        </div>
      </div>
      <div id="packsList" style="max-height: 400px; overflow-y: auto;">
        <p style="font-size: 12px; color: var(--muted); text-align: center; padding: 20px;">Loading packs...</p>
      </div>
      <button onclick="document.getElementById('offlineManageModal').style.display='none'" class="modal-btn primary" style="width: 100%; margin-top: 16px;">Close</button>
    </div>
  </div>

  <div id="areaLegend">
    <div class="legend-item">
      <div class="legend-swatch" style="background:#16a34a;"></div>
      <span>Open</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch" style="background:#dc2626;"></div>
      <span>Closed</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch hatch"></div>
      <span>Archery</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch dots"></div>
      <span>Cantonment</span>
    </div>
  </div>

  <!-- Modal for offline packs, confirmations, etc. -->
  <div id="modalBackdrop" class="modal-backdrop">
    <div class="modal">
      <h3 id="modalTitle">Title</h3>
      <div id="modalBody">Body</div>
      <div class="modal-buttons">
        <button id="modalCancel" class="modal-btn secondary">Cancel</button>
        <button id="modalConfirm" class="modal-btn primary">OK</button>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Leaflet Pattern Plugin (FIX for hatch + dots) -->
  <script src="https://unpkg.com/leaflet.pattern@0.1.0/dist/leaflet.pattern.js"></script>

  <!-- Leaflet Routing Machine -->
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

  <!-- Hunt AO cloud data config (set once) -->
  <script>
    window.HUNTAO_CONTOURS_API_BASE = "";
    window.HUNTAO_HILLSHADE_URL = "";
  </script>

  <script>
    // -----------------------------
    // Basic map setup
    // -----------------------------
    const BASE_LOCATIONS = {
      fort_leonard_wood: {
        label: "Fort Leonard Wood",
        center: [37.75, -92.15],
        zoom: 12
      }
    };

    const DEFAULT_BASE_ID = "fort_leonard_wood";

    const map = L.map("map", {
      center: BASE_LOCATIONS[DEFAULT_BASE_ID].center,
      zoom: BASE_LOCATIONS[DEFAULT_BASE_ID].zoom,
      zoomControl: false
    });

    L.control.zoom({ position: "bottomright" }).addTo(map);

    // Basemaps
    const satellite = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      { maxZoom: 19, attribution: "ESRI World Imagery" }
    );

    const osm = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      { maxZoom: 19, attribution: "&copy; OpenStreetMap contributors" }
    );

    const usgsTopo = L.tileLayer(
      "https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}",
      { maxZoom: 16, attribution: "USGS" }
    );

    const esriTopo = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
      { maxZoom: 19, attribution: "ESRI" }
    );

    const otmTopo = L.tileLayer(
      "https://tile.opentopomap.org/{z}/{x}/{y}.png",
      { maxZoom: 17, attribution: "OpenTopoMap" }
    );

    satellite.addTo(map);

    // Overlays: Vector-based contour lines (OnX style)
    const CONTOURS_API_BASE = String(window.HUNTAO_CONTOURS_API_BASE || "").trim().replace(/\/$/, "");
    const HILLSHADE_TILE_URL = String(window.HUNTAO_HILLSHADE_URL || "").trim() || "https://services.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}";

    let contoursMedData = null;
    let contoursHighData = null;
    let currentContoursLayer = null;
    let remoteContoursEnabled = Boolean(CONTOURS_API_BASE);
    let remoteContoursHealthy = true;
    let lastContoursRequestId = 0;

    // Local fallback data (used when remote API is unavailable)
    async function loadLocalContoursData() {
      try {
        contoursMedData = await fetch('/contours_med.geojson').then(r => {
          if (!r.ok) throw new Error(`Failed to load med: ${r.status}`);
          return r.json();
        });
      } catch (err) {
        console.error('Failed to load medium contours:', err);
      }

      try {
        contoursHighData = await fetch('/contours_high.geojson').then(r => {
          if (!r.ok) throw new Error(`Failed to load high: ${r.status}`);
          return r.json();
        });
      } catch (err) {
        contoursHighData = null;
        console.warn('High-resolution contours unavailable; using medium contours only.');
      }
    }

    function buildContoursApiUrl() {
      const bounds = map.getBounds();
      const bbox = [
        bounds.getWest().toFixed(6),
        bounds.getSouth().toFixed(6),
        bounds.getEast().toFixed(6),
        bounds.getNorth().toFixed(6)
      ].join(',');
      const zoom = map.getZoom();
      const simplify = zoom >= 15 ? 0 : zoom >= 13 ? 0.00003 : 0.00008;
      const limit = zoom >= 15 ? 18000 : 12000;
      return `${CONTOURS_API_BASE}/api/contours?bbox=${bbox}&limit=${limit}&simplify=${simplify}`;
    }

    // Style contour lines - dark yellow like OnX
    function getContoursStyle(zoom) {
      const weight = zoom >= 16 ? 1 : zoom >= 13 ? 0.7 : 0.5;
      return {
        color: '#c9a227',
        weight: weight,
        opacity: 0.5,
        lineCap: 'round',
        lineJoin: 'round'
      };
    }

    // Create layer for a specific zoom level
    function createContoursLayer(data, zoom) {
      if (!data || !data.features || data.features.length === 0) {
        console.warn('No contour data available');
        return null;
      }
      
      const style = getContoursStyle(zoom);
      
      // Simplify geometry for better performance - reduce coordinate density
      const simplificationFactor = zoom >= 16 ? 0 : zoom >= 13 ? 1 : 2;
      
      const simplifyGeometry = (feature) => {
        if (simplificationFactor === 0) return feature;
        
        if (feature.geometry.type === 'LineString') {
          const coords = feature.geometry.coordinates;
          const simplified = coords.filter((c, i) => i % (simplificationFactor + 1) === 0);
          return {
            ...feature,
            geometry: { ...feature.geometry, coordinates: simplified }
          };
        }
        return feature;
      };
      
      const simplifiedData = {
        ...data,
        features: data.features.map(simplifyGeometry)
      };
      
      // Use SVG renderer for better compatibility
      return L.geoJSON(simplifiedData, {
        style: () => style,
        interactive: false
      });
    }

    function renderContoursLayer(data) {
      const zoom = map.getZoom();

      // Remove current layer if it exists
      if (currentContoursLayer) {
        map.removeLayer(currentContoursLayer);
        currentContoursLayer = null;
      }

      // Add appropriate layer based on zoom (for local fallback)
      if (zoom >= 16 && data === null && contoursHighData) {
        currentContoursLayer = createContoursLayer(contoursHighData, zoom);
        if (currentContoursLayer) currentContoursLayer.addTo(map);
        return;
      }

      if (zoom >= 10 && data === null && contoursMedData) {
        currentContoursLayer = createContoursLayer(contoursMedData, zoom);
        if (currentContoursLayer) currentContoursLayer.addTo(map);
        return;
      }

      if (data) {
        currentContoursLayer = createContoursLayer(data, zoom);
        if (currentContoursLayer) currentContoursLayer.addTo(map);
      }
    }

    async function updateContours() {
      if (!contoursActive) return;

      if (!remoteContoursEnabled || !remoteContoursHealthy) {
        renderContoursLayer(null);
        return;
      }

      const requestId = ++lastContoursRequestId;
      try {
        const remoteData = await fetch(buildContoursApiUrl(), { cache: 'no-store' }).then(r => {
          if (!r.ok) throw new Error(`Contours API failed: ${r.status}`);
          return r.json();
        });

        if (requestId !== lastContoursRequestId) return;

        const hasRemoteFeatures = Boolean(
          remoteData &&
          remoteData.type === 'FeatureCollection' &&
          Array.isArray(remoteData.features) &&
          remoteData.features.length > 0
        );

        if (!hasRemoteFeatures) {
          console.warn('Remote contours returned no features; using local fallback.');
          await loadLocalContoursData();
          renderContoursLayer(null);
          return;
        }

        renderContoursLayer(remoteData);
      } catch (err) {
        console.warn('Remote contours unavailable; using local fallback.', err);
        remoteContoursHealthy = false;
        await loadLocalContoursData();
        renderContoursLayer(null);
      }
    }

    // Load local fallback once in background
    loadLocalContoursData();

    // Update contours when view changes
    map.on('zoomend', updateContours);
    map.on('moveend', updateContours);

    // Hillshade via local or cloud XYZ tiles
    const hillshadeLayer = L.tileLayer(
      HILLSHADE_TILE_URL,
      {
        maxZoom: 19,
        opacity: 0.4,
        attribution: HILLSHADE_TILE_URL.includes('hillshade_tiles') ? "Local Hillshade" : "World Hillshade",
        className: "hillshade-layer"
      }
    );

    // Track which overlays are active
    let contoursActive = false;
    let hillshadeActive = false;

    // Terrain overlays
    const contoursToggle = document.getElementById("contoursToggle");
    const hillshadeToggle = document.getElementById("hillshadeToggle");

    contoursToggle.addEventListener("change", () => {
      if (contoursToggle.checked && !contoursActive) {
        contoursActive = true;
        if (remoteContoursEnabled) remoteContoursHealthy = true;
        updateContours();
      } else if (!contoursToggle.checked && contoursActive) {
        contoursActive = false;
        if (currentContoursLayer) {
          map.removeLayer(currentContoursLayer);
          currentContoursLayer = null;
        }
      }
    });

    hillshadeToggle.addEventListener("change", () => {
      if (hillshadeToggle.checked && !hillshadeActive) {
        hillshadeLayer.addTo(map);
        hillshadeActive = true;
      } else if (!hillshadeToggle.checked && hillshadeActive) {
        map.removeLayer(hillshadeLayer);
        hillshadeActive = false;
      }
    });

    // -----------------------------
    // Drawer logic
    // -----------------------------
    const drawer = document.getElementById("drawer");
    const drawerToggle = document.getElementById("drawerToggle");

    drawerToggle.addEventListener("click", (e) => {
      e.stopPropagation();
      drawer.classList.toggle("open");
    });

    document.addEventListener("click", (e) => {
      if (!drawer.classList.contains("open")) return;
      if (drawer.contains(e.target)) return;
      if (drawerToggle.contains(e.target)) return;
      drawer.classList.remove("open");
    });

    document.querySelectorAll('input[name="basemap"]').forEach(radio => {
      radio.addEventListener("change", () => setBasemap(radio.value));
    });

    function setBasemap(value) {
      [satellite, osm, usgsTopo, esriTopo, otmTopo].forEach(l => map.removeLayer(l));
      switch (value) {
        case "satellite": satellite.addTo(map); break;
        case "osm": osm.addTo(map); break;
        case "usgs": usgsTopo.addTo(map); break;
        case "esri": esriTopo.addTo(map); break;
        case "otm": otmTopo.addTo(map); break;
      }
    }

    // -----------------------------
    // HUD + GPS
    // -----------------------------
    const hudLocation = document.getElementById("hudLocation");
    const hudAccuracy = document.getElementById("hudAccuracy");
    const hudCurrentArea = document.getElementById("hudCurrentArea");
    const hudTime = document.getElementById("hudTime");
    const hudWeather = document.getElementById("hudWeather");
    const baseSelect = document.getElementById("baseSelect");

    let areaFeatures = []; // Store loaded area features for point-in-polygon

    // Point-in-polygon algorithm (ray casting)
    function isPointInPolygon(point, polygon) {
      const [x, y] = point;
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];
        const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * (y - yi)) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function getCurrentArea(lat, lng) {
      for (const feature of areaFeatures) {
        const geom = feature.geometry;
        if (geom.type === "Polygon") {
          const coords = geom.coordinates[0];
          const ring = coords.map(coord => [coord[0], coord[1]]);
          if (isPointInPolygon([lng, lat], ring)) {
            return feature.properties.area_name || "Unknown Area";
          }
        } else if (geom.type === "MultiPolygon") {
          for (const polygon of geom.coordinates) {
            const ring = polygon[0].map(coord => [coord[0], coord[1]]);
            if (isPointInPolygon([lng, lat], ring)) {
              return feature.properties.area_name || "Unknown Area";
            }
          }
        }
      }
      return "Outside Known Areas";
    }

    function compactReferenceName(name) {
      let text = String(name || "").trim();
      if (!text) return "Current Position";

      const replacements = [
        [/\bFort Leonard Wood\b/gi, "FLW"],
        [/\bMilitary Reservation\b/gi, "Res."],
        [/\bTraining Area\b/gi, "TA"],
        [/\bCantonment\b/gi, "CAN"],
        [/\s+/g, " "]
      ];

      for (const [pattern, value] of replacements) {
        text = text.replace(pattern, value);
      }

      if (text.length > 34) {
        text = `${text.slice(0, 31)}...`;
      }

      return text;
    }

    const weatherLocationCache = new Map();
    async function getWeatherLocationLabel(lat, lng) {
      const cacheKey = `${lat.toFixed(3)},${lng.toFixed(3)}`;
      if (weatherLocationCache.has(cacheKey)) {
        return weatherLocationCache.get(cacheKey);
      }

      let referencePoint = "Current Location";
      let city = "";
      let state = "";

      try {
        const nominatimUrl = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lng}&addressdetails=1&zoom=18`;
        const response = await fetch(nominatimUrl);
        const data = await response.json();
        const address = data?.address || {};
        referencePoint = address.road || address.neighbourhood || address.suburb || address.hamlet || address.village || address.town || address.city || referencePoint;
        city = address.city || address.town || address.village || address.municipality || address.county || city;
        state = address.state || address.region || address.country || state;
      } catch {}

      if (!city || !state) {
        try {
          const openMeteoUrl = `https://geocoding-api.open-meteo.com/v1/reverse?latitude=${lat}&longitude=${lng}&count=1&language=en&format=json`;
          const response = await fetch(openMeteoUrl);
          const data = await response.json();
          const row = Array.isArray(data?.results) ? data.results[0] : null;
          referencePoint = row?.name || referencePoint;
          city = city || row?.name || row?.admin2 || "";
          state = state || row?.admin1 || row?.country || "";
        } catch {}
      }

      if (!city || !state) {
        try {
          const bdcUrl = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lng}&localityLanguage=en`;
          const response = await fetch(bdcUrl);
          const data = await response.json();
          referencePoint = data?.locality || data?.city || referencePoint;
          city = city || data?.city || data?.locality || "";
          state = state || data?.principalSubdivision || data?.countryName || "";
        } catch {}
      }

      const compactRef = compactReferenceName(referencePoint || city || "Current Location");
      const cityState = [city, state].filter(Boolean).join(", ");
      const label = cityState ? `${compactRef} â€¢ ${cityState}` : compactRef;
      weatherLocationCache.set(cacheKey, label);
      return label;
    }

    let gpsWatchId = null;
    let currentPosition = null;
    let gpsMarker = null;
    let gpsAccuracyCircle = null;
    let didCenterOnInitialGps = false;
    let lastWeatherFetchAt = 0;
    let lastWeatherData = null;
    let currentWind = { speed: 0, direction: 0, angle: 0 };

    function goToBase(baseId) {
      const base = BASE_LOCATIONS[baseId];
      if (!base) return;
      map.setView(base.center, base.zoom);
    }

    if (baseSelect) {
      baseSelect.addEventListener("change", () => {
        goToBase(baseSelect.value);
      });
    }

    function updateGpsVisuals(latitude, longitude, accuracy) {
      const latlng = L.latLng(latitude, longitude);

      if (!gpsMarker) {
        gpsMarker = L.circleMarker(latlng, {
          radius: 7,
          color: "#11161a",
          weight: 2,
          fillColor: "#ff7f36",
          fillOpacity: 0.95,
          pane: "markerPane"
        }).addTo(map);
      } else {
        gpsMarker.setLatLng(latlng);
      }

      if (!gpsAccuracyCircle) {
        gpsAccuracyCircle = L.circle(latlng, {
          radius: accuracy || 0,
          color: "#ff7f36",
          weight: 1,
          opacity: 0.55,
          fillColor: "#ff7f36",
          fillOpacity: 0.12,
          interactive: false
        }).addTo(map);
      } else {
        gpsAccuracyCircle.setLatLng(latlng);
        gpsAccuracyCircle.setRadius(Math.max(1, accuracy || 0));
      }
    }

    function updateTime() {
      const now = new Date();
      hudTime.textContent = "Time: " + now.toLocaleTimeString();
    }
    setInterval(updateTime, 1000);
    updateTime();

    function startGPS() {
      if (!navigator.geolocation) return;
      if (gpsWatchId !== null) return;

      gpsWatchId = navigator.geolocation.watchPosition(
        pos => {
          const { latitude, longitude, accuracy, speed, heading } = pos.coords;
          currentPosition = [latitude, longitude];

          hudLocation.textContent = `Lat: ${latitude.toFixed(5)}, Lng: ${longitude.toFixed(5)}`;
          hudAccuracy.textContent = `Accuracy: ${accuracy ? accuracy.toFixed(0) + " m" : "---"}`;
          hudCurrentArea.textContent = `Area: ${getCurrentArea(latitude, longitude)}`;
          updateGpsVisuals(latitude, longitude, accuracy);

          if (!didCenterOnInitialGps) {
            map.setView([latitude, longitude], Math.max(map.getZoom(), 15));
            didCenterOnInitialGps = true;
          }

          if (!lastWeatherData || Date.now() - lastWeatherFetchAt > 10 * 60 * 1000) {
            fetchWeather().catch(err => console.warn("Weather refresh from GPS update failed:", err));
          }
        },
        err => console.warn("GPS error:", err),
        { enableHighAccuracy: true, maximumAge: 5000, timeout: 20000 }
      );
    }

    function centerOnCurrentLocationOnce() {
      if (!navigator.geolocation || didCenterOnInitialGps) return;

      navigator.geolocation.getCurrentPosition(
        pos => {
          const { latitude, longitude, accuracy } = pos.coords;
          currentPosition = [latitude, longitude];
          hudLocation.textContent = `Lat: ${latitude.toFixed(5)}, Lng: ${longitude.toFixed(5)}`;
          hudAccuracy.textContent = `Accuracy: ${accuracy ? accuracy.toFixed(0) + " m" : "---"}`;
          hudCurrentArea.textContent = `Area: ${getCurrentArea(latitude, longitude)}`;
          updateGpsVisuals(latitude, longitude, accuracy);
          map.setView([latitude, longitude], Math.max(map.getZoom(), 15));
          didCenterOnInitialGps = true;
        },
        () => {},
        { enableHighAccuracy: true, maximumAge: 60000, timeout: 12000 }
      );
    }

    startGPS();
    centerOnCurrentLocationOnce();

    const gpsFollowBtn = document.getElementById("gpsFollowBtn");
    gpsFollowBtn.addEventListener("click", () => {
      if (!currentPosition) {
        alert("No GPS fix yet.");
        return;
      }
      map.setView(currentPosition, Math.max(map.getZoom(), 15));
    });

    // HUD weather (real data)
    async function updateWeather() {
      if (!lastWeatherData) {
        hudWeather.textContent = "Weather: loading...";
        try {
          await fetchWeather();
        } catch (err) {
          console.warn("HUD weather fetch failed:", err);
        }
      }

      if (!lastWeatherData) return;

      const tempF = (lastWeatherData.temperature_2m * 9 / 5 + 32).toFixed(1);
      const windMph = (currentWind.speed * 0.621371).toFixed(1);
      const windDir = getWindDirection(currentWind.direction);
      hudWeather.textContent = `Weather: ${tempF}Â°F, Wind ${windMph} mph ${windDir}`;
    }
    updateWeather();
    setInterval(updateWeather, 10 * 60 * 1000);

    // -----------------------------
    // Account + Sync
    // -----------------------------
    const authStatus = document.getElementById("authStatus");
    const syncStatus = document.getElementById("syncStatus");
    const liabilityGate = document.getElementById("liabilityGate");
    const liabilityAcknowledge = document.getElementById("liabilityAcknowledge");
    const liabilityAgreeBtn = document.getElementById("liabilityAgreeBtn");
    const liabilityDeclineBtn = document.getElementById("liabilityDeclineBtn");
    const liabilityDeclineNote = document.getElementById("liabilityDeclineNote");
    const openAccountModalBtn = document.getElementById("openAccountModalBtn");
    const accountModalBackdrop = document.getElementById("accountModalBackdrop");
    const accountModalClose = document.getElementById("accountModalClose");
    const openSignupModalBtn = document.getElementById("openSignupModalBtn");
    const signupModalBackdrop = document.getElementById("signupModalBackdrop");
    const signupModalClose = document.getElementById("signupModalClose");
    const switchToLoginBtn = document.getElementById("switchToLoginBtn");
    const authEmailInput = document.getElementById("authEmailInput");
    const authPasswordInput = document.getElementById("authPasswordInput");
    const signupEmailInput = document.getElementById("signupEmailInput");
    const signupPasswordInput = document.getElementById("signupPasswordInput");
    const signupFullNameInput = document.getElementById("signupFullNameInput");
    const requestResetBtn = document.getElementById("requestResetBtn");
    const requestResetSignedInBtn = document.getElementById("requestResetSignedInBtn");
    const signedOutAccountSection = document.getElementById("signedOutAccountSection");
    const signedInAccountSection = document.getElementById("signedInAccountSection");
    const signedInEmailLabel = document.getElementById("signedInEmailLabel");
    const authModalSubtitle = document.getElementById("authModalSubtitle");
    const resetPasswordPanel = document.getElementById("resetPasswordPanel");
    const resetTokenInput = document.getElementById("resetTokenInput");
    const newPasswordInput = document.getElementById("newPasswordInput");
    const resetPasswordBtn = document.getElementById("resetPasswordBtn");
    const signupBtn = document.getElementById("signupBtn");
    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const syncNowBtn = document.getElementById("syncNowBtn");
    const profileFullName = document.getElementById("profileFullName");
    const profilePhone = document.getElementById("profilePhone");
    const profileVehicle = document.getElementById("profileVehicle");
    const profileEmergencyContact = document.getElementById("profileEmergencyContact");
    const profileNotes = document.getElementById("profileNotes");

    const AUTH_TOKEN_KEY = "huntao_auth_token";
    let authToken = localStorage.getItem(AUTH_TOKEN_KEY) || "";
    let currentUser = null;
    let syncSaveTimer = null;
    let liabilityAccepted = false;

    function setSyncStatus(text) {
      syncStatus.textContent = `Sync status: ${text}`;
    }

    function updateLiabilityGateState() {
      liabilityAgreeBtn.disabled = !liabilityAcknowledge.checked;
    }

    function openLiabilityGate() {
      liabilityAccepted = false;
      liabilityAcknowledge.checked = false;
      liabilityDeclineNote.textContent = "";
      updateLiabilityGateState();
      liabilityGate.style.display = "flex";
    }

    function closeLiabilityGate() {
      liabilityAccepted = true;
      liabilityGate.style.display = "none";
    }

    function showResetPanel() {
      resetPasswordPanel.style.display = "block";
    }

    function hideResetPanel() {
      resetPasswordPanel.style.display = "none";
      resetTokenInput.value = "";
      newPasswordInput.value = "";
    }

    function setAccountModalMode() {
      const isSignedIn = Boolean(currentUser && authToken);
      signedOutAccountSection.style.display = isSignedIn ? "none" : "block";
      signedInAccountSection.style.display = isSignedIn ? "block" : "none";

      if (isSignedIn) {
        authModalSubtitle.textContent = "Manage your account session and offline packs.";
        signedInEmailLabel.textContent = currentUser.email || "";
        authEmailInput.value = currentUser.email || authEmailInput.value;
      } else {
        authModalSubtitle.textContent = "Access your synced waypoints and tracks.";
        signedInEmailLabel.textContent = "";
      }
    }

    function openLoginModal() {
      if (!liabilityAccepted) {
        alert("You must accept the Boundary & Liability Acknowledgment before using HuntAO.");
        openLiabilityGate();
        return;
      }
      setAccountModalMode();
      accountModalBackdrop.style.display = "flex";
      if (currentUser) {
        requestResetSignedInBtn.focus();
      } else {
        authEmailInput.focus();
      }
    }

    function closeLoginModal() {
      accountModalBackdrop.style.display = "none";
      hideResetPanel();
    }

    function openSignupModal() {
      signupModalBackdrop.style.display = "flex";
      signupEmailInput.focus();
    }

    function closeSignupModal() {
      signupModalBackdrop.style.display = "none";
    }

    function setAuthUi() {
      if (currentUser) {
        const verified = currentUser.emailVerified === false ? " (unverified)" : "";
        authStatus.textContent = `Signed in: ${currentUser.email}${verified}`;
        openAccountModalBtn.textContent = "Open Account";
      } else {
        authStatus.textContent = "Not signed in";
        openAccountModalBtn.textContent = "Open Login";
      }
      setAccountModalMode();
    }

    openAccountModalBtn.addEventListener("click", () => {
      openLoginModal();
    });

    accountModalClose.addEventListener("click", () => {
      closeLoginModal();
    });

    accountModalBackdrop.addEventListener("click", e => {
      if (e.target === accountModalBackdrop) {
        closeLoginModal();
      }
    });

    openSignupModalBtn.addEventListener("click", () => {
      closeLoginModal();
      openSignupModal();
    });

    signupModalClose.addEventListener("click", () => {
      closeSignupModal();
    });

    switchToLoginBtn.addEventListener("click", () => {
      closeSignupModal();
      openLoginModal();
    });

    signupModalBackdrop.addEventListener("click", e => {
      if (e.target === signupModalBackdrop) {
        closeSignupModal();
      }
    });

    function getProfilePayload() {
      return {
        fullName: profileFullName.value.trim(),
        phone: profilePhone.value.trim(),
        vehicle: profileVehicle.value.trim(),
        emergencyContact: profileEmergencyContact.value.trim(),
        notes: profileNotes.value.trim()
      };
    }

    function setProfileFields(profile = {}) {
      profileFullName.value = profile.fullName || "";
      profilePhone.value = profile.phone || "";
      profileVehicle.value = profile.vehicle || "";
      profileEmergencyContact.value = profile.emergencyContact || "";
      profileNotes.value = profile.notes || "";
    }

    async function apiFetch(pathname, options = {}) {
      const headers = { "Content-Type": "application/json", ...(options.headers || {}) };
      if (authToken) headers.Authorization = `Bearer ${authToken}`;
      const response = await fetch(pathname, { ...options, headers });
      const contentType = response.headers.get("content-type") || "";
      const payload = contentType.includes("application/json") ? await response.json() : null;
      if (!response.ok) {
        throw new Error(payload?.error || `Request failed: ${response.status}`);
      }
      return payload;
    }

    async function pushSyncNow() {
      if (!authToken || !currentUser) return;
      setSyncStatus("uploading...");
      await apiFetch("/api/sync", {
        method: "PUT",
        body: JSON.stringify({
          waypoints: waypointRecords,
          tracks: savedTracks,
          profile: getProfilePayload()
        })
      });
      setSyncStatus(`synced ${new Date().toLocaleTimeString()}`);
    }

    function queueSyncSave() {
      if (!authToken || !currentUser) return;
      setSyncStatus("pending changes...");
      clearTimeout(syncSaveTimer);
      syncSaveTimer = setTimeout(async () => {
        try {
          await pushSyncNow();
        } catch (err) {
          console.warn("Sync save failed", err);
          setSyncStatus("sync failed");
        }
      }, 1200);
    }

    async function loadCloudSync() {
      if (!authToken || !currentUser) return;
      setSyncStatus("loading from cloud...");
      const synced = await apiFetch("/api/sync", { method: "GET" });
      waypointRecords = Array.isArray(synced.waypoints) ? synced.waypoints : [];
      savedTracks = Array.isArray(synced.tracks) ? synced.tracks : [];
      setProfileFields(synced.profile || {});
      renderAllWaypoints();
      renderSavedTracks();
      setSyncStatus(`loaded ${new Date().toLocaleTimeString()}`);
    }

    async function initializeAuthFromToken() {
      if (!authToken) {
        setAuthUi();
        return;
      }
      try {
        const data = await apiFetch("/api/auth/me", { method: "GET" });
        currentUser = data.user;
        setAuthUi();
        await loadCloudSync();
      } catch {
        authToken = "";
        currentUser = null;
        localStorage.removeItem(AUTH_TOKEN_KEY);
        setAuthUi();
        setSyncStatus("idle");
      }
    }

    function prefillResetFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const resetToken = params.get("resetToken");
      const email = params.get("email");
      if (resetToken) {
        showResetPanel();
        resetTokenInput.value = resetToken;
      }
      if (email) {
        authEmailInput.value = email;
      }
      if (resetToken || email) {
        openLoginModal();
        setSyncStatus("Password reset link loaded. Enter a new password and click Reset Password.");
      }
    }

    async function requestPasswordResetFor(email) {
      const normalized = String(email || "").trim();
      if (!normalized) {
        alert("Enter your email first.");
        return;
      }

      const data = await apiFetch("/api/auth/request-password-reset", {
        method: "POST",
        body: JSON.stringify({ email: normalized })
      });
      if (data.resetLink) {
        console.info("Dev reset link:", data.resetLink);
      }
      showResetPanel();
      alert(data.message || "If the email exists, reset instructions were sent.");
    }

    signupBtn.addEventListener("click", async () => {
      try {
        const email = signupEmailInput.value.trim();
        const password = signupPasswordInput.value;
        const fullName = signupFullNameInput.value.trim();
        profileFullName.value = fullName;
        const data = await apiFetch("/api/auth/signup", {
          method: "POST",
          body: JSON.stringify({ email, password, fullName, liabilityAccepted: liabilityAccepted === true })
        });
        authToken = data.token;
        currentUser = data.user;
        localStorage.setItem(AUTH_TOKEN_KEY, authToken);
        authEmailInput.value = email;
        authPasswordInput.value = "";
        setAuthUi();
        await pushSyncNow();
        signupEmailInput.value = "";
        signupPasswordInput.value = "";
        signupFullNameInput.value = "";
        closeSignupModal();
        closeLoginModal();
        if (data.verificationRequired) {
          alert("Account created. Check your email to verify before login on other devices.");
          if (data.verificationLink) {
            console.info("Dev verification link:", data.verificationLink);
          }
        } else {
          alert("Account created and signed in.");
        }
      } catch (err) {
        alert(`Signup failed: ${err.message}`);
      }
    });

    loginBtn.addEventListener("click", async () => {
      try {
        const email = authEmailInput.value.trim();
        const password = authPasswordInput.value;
        const data = await apiFetch("/api/auth/login", {
          method: "POST",
          body: JSON.stringify({ email, password, liabilityAccepted: liabilityAccepted === true })
        });
        authToken = data.token;
        currentUser = data.user;
        localStorage.setItem(AUTH_TOKEN_KEY, authToken);
        setAuthUi();
        await loadCloudSync();
        closeLoginModal();
        alert("Logged in and synced.");
      } catch (err) {
        alert(`Login failed: ${err.message}`);
      }
    });

    requestResetBtn.addEventListener("click", async () => {
      try {
        await requestPasswordResetFor(authEmailInput.value.trim());
      } catch (err) {
        alert(`Could not request password reset: ${err.message}`);
      }
    });

    requestResetSignedInBtn.addEventListener("click", async () => {
      try {
        await requestPasswordResetFor(currentUser?.email || authEmailInput.value.trim());
      } catch (err) {
        alert(`Could not request password reset: ${err.message}`);
      }
    });

    resetPasswordBtn.addEventListener("click", async () => {
      try {
        const email = authEmailInput.value.trim();
        const token = resetTokenInput.value.trim();
        const newPassword = newPasswordInput.value;
        const data = await apiFetch("/api/auth/reset-password", {
          method: "POST",
          body: JSON.stringify({ email, token, newPassword })
        });
        newPasswordInput.value = "";
        resetTokenInput.value = "";
        alert(data.message || "Password reset successful.");
      } catch (err) {
        alert(`Reset failed: ${err.message}`);
      }
    });

    logoutBtn.addEventListener("click", () => {
      authToken = "";
      currentUser = null;
      localStorage.removeItem(AUTH_TOKEN_KEY);
      clearTimeout(syncSaveTimer);
      authEmailInput.value = "";
      authPasswordInput.value = "";
      signupEmailInput.value = "";
      signupPasswordInput.value = "";
      signupFullNameInput.value = "";
      hideResetPanel();
      setProfileFields({});
      setAuthUi();
      setSyncStatus("idle");
      closeLoginModal();
    });

    syncNowBtn.addEventListener("click", async () => {
      if (!authToken || !currentUser) {
        alert("Sign in first to sync.");
        return;
      }
      try {
        await pushSyncNow();
      } catch (err) {
        alert(`Sync failed: ${err.message}`);
      }
    });

    [profileFullName, profilePhone, profileVehicle, profileEmergencyContact, profileNotes].forEach(input => {
      input.addEventListener("input", queueSyncSave);
    });

    setAuthUi();
    setSyncStatus("idle");
    openLiabilityGate();
    liabilityAcknowledge.addEventListener("change", updateLiabilityGateState);
    liabilityAgreeBtn.addEventListener("click", () => {
      closeLiabilityGate();
    });
    liabilityDeclineBtn.addEventListener("click", () => {
      liabilityAccepted = false;
      liabilityDeclineNote.textContent = "Access is blocked until you acknowledge and agree.";
      liabilityAcknowledge.checked = false;
      updateLiabilityGateState();
    });
  prefillResetFromUrl();

    // -----------------------------
    // Waypoints & tracks (simple)

    // Define waypoint types with custom SVG icons
    const waypointTypes = {
      'treestand': {
        label: 'Treestand',
        pin: '#2a4a40',
        icon: '#ecf2f0',
        svg: '<g stroke="#ecf2f0" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"><line x1="16" y1="11" x2="16" y2="24"/><path d="M12 13 L16 9 L20 13"/><line x1="12" y1="17" x2="20" y2="17"/></g>'
      },
      'blind': {
        label: 'Ground Blind',
        pin: '#385347',
        icon: '#ecf2f0',
        svg: '<g stroke="#ecf2f0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"><path d="M10 20 L13 13 H19 L22 20 Z"/><line x1="13" y1="13" x2="16" y2="10"/><line x1="19" y1="13" x2="16" y2="10"/></g>'
      },
      'waterhole': {
        label: 'Water Hole',
        pin: '#2f5360',
        icon: '#d9ecff',
        svg: '<g fill="none" stroke="#d9ecff" stroke-width="1.5" stroke-linecap="round"><path d="M12 17 C14 15, 18 15, 20 17"/><path d="M11 20 C13.8 18, 18.2 18, 21 20"/><path d="M10 23 C13.5 21, 18.5 21, 22 23"/></g>'
      },
      'feedingarea': {
        label: 'Feeding Area',
        pin: '#4f5a36',
        icon: '#f3f1dc',
        svg: '<g fill="#f3f1dc"><circle cx="12" cy="17" r="1.5"/><circle cx="16" cy="14" r="1.5"/><circle cx="20" cy="17" r="1.5"/><circle cx="14" cy="21" r="1.5"/><circle cx="18" cy="21" r="1.5"/></g>'
      },
      'beddingarea': {
        label: 'Bedding Area',
        pin: '#5a4b3a',
        icon: '#f5e9dc',
        svg: '<g fill="none" stroke="#f5e9dc" stroke-width="1.5" stroke-linecap="round"><ellipse cx="16" cy="19" rx="6" ry="3.8"/><path d="M10 19 Q13 22.8 16 22.8 Q19 22.8 22 19"/></g>'
      },
      'signpost': {
        label: 'Sign Post',
        pin: '#4b4f57',
        icon: '#ecf2f0',
        svg: '<g fill="none" stroke="#ecf2f0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="16" y1="10" x2="16" y2="24"/><path d="M16 12 H22 L20.5 15 H16"/></g>'
      },
      'saltlick': {
        label: 'Salt Lick',
        pin: '#6b5d45',
        icon: '#fff3d6',
        svg: '<g fill="none" stroke="#fff3d6" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"><path d="M11 21 L13.5 14.5 H18.5 L21 21 Z"/><line x1="13" y1="18" x2="19" y2="18"/></g>'
      },
      'generic': {
        label: 'Waypoint',
        pin: '#2f5360',
        icon: '#ecf2f0',
        svg: '<g fill="none" stroke="#ecf2f0" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><circle cx="16" cy="18" r="4"/><path d="M16 14 V22"/><path d="M12 18 H20"/></g>'
      }
    };

    // Create icon for a specific waypoint type
    function createWaypointIcon(type) {
      const typeData = waypointTypes[type] || waypointTypes['generic'];
      return L.divIcon({
        html: `<svg width="34" height="44" viewBox="0 0 34 44" xmlns="http://www.w3.org/2000/svg" aria-label="${typeData.label}">
          <path d="M17 1C9.82 1 4 6.82 4 14c0 8.72 13 28 13 28s13-19.28 13-28C30 6.82 24.18 1 17 1z" fill="${typeData.pin}" stroke="#0f1418" stroke-width="1.6"/>
          <circle cx="17" cy="18" r="8.5" fill="rgba(13,20,25,0.32)" stroke="rgba(236,242,240,0.22)" stroke-width="0.8"/>
          ${typeData.svg}
        </svg>`,
        iconSize: [34, 44],
        iconAnchor: [17, 44],
        popupAnchor: [0, -44],
        className: 'waypoint-marker'
      });
    }

    // Create wind direction arrow icon
    function createWindArrowIcon() {
      return L.divIcon({
        html: `<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(${(currentWind.angle + 180) % 360}deg);">
          <path d="M 24 4 L 32 28 L 24 24 L 16 28 Z" fill="#c8ad3c" opacity="0.95" stroke="#111111" stroke-width="1"/>
        </svg>`,
        iconSize: [48, 48],
        iconAnchor: [24, 24],
        popupAnchor: [0, -20],
        className: 'wind-arrow-icon'
      });
    }

    const addWaypointBtn = document.getElementById("addWaypointBtn");
    let waypointLayer = L.layerGroup().addTo(map);
    let waypointRecords = [];
    const waypointVisualsById = new Map();
    let savedTracks = [];
    let savedTrackLayers = [];
    let placingWaypoint = false;

    function setWaypointPlacementMode(enabled) {
      placingWaypoint = enabled;
      addWaypointBtn.classList.toggle("active", enabled);
      addWaypointBtn.textContent = enabled ? "Click Map to Place..." : "Add Waypoint";
    }

    function escapeHtmlText(value) {
      return String(value || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function buildWaypointPopup(record) {
      const windDir = getWindDirection(currentWind.angle || 0);
      const windMph = ((currentWind.speed || 0) * 0.621371).toFixed(1);
      const typeLabel = waypointTypes[record.type]?.label || waypointTypes.generic.label;
      const displayName = escapeHtmlText(record.name || typeLabel);
      return `<strong>${displayName}</strong><br><small>Lat: ${record.lat.toFixed(5)}, Lng: ${record.lng.toFixed(5)}</small><br><small style="color: var(--gold-strong);">Wind: ${windMph} mph ${windDir}</small><br><small style="color: var(--muted);">Drag to move<br>Right-click to delete</small>`;
    }

    function removeWaypointById(id, shouldSync = true) {
      const visuals = waypointVisualsById.get(id);
      if (visuals) {
        if (visuals.marker) waypointLayer.removeLayer(visuals.marker);
        if (visuals.windArrow) waypointLayer.removeLayer(visuals.windArrow);
        waypointVisualsById.delete(id);
      }
      waypointRecords = waypointRecords.filter(wp => wp.id !== id);
      if (shouldSync) queueSyncSave();
    }

    function addWaypointRecord(record, openPopup = false) {
      const latlng = L.latLng(record.lat, record.lng);
      const marker = L.marker(latlng, { draggable: true, icon: createWaypointIcon(record.type) }).addTo(waypointLayer);
      const windArrow = L.marker(latlng, { icon: createWindArrowIcon() }).addTo(waypointLayer);

      marker.bindPopup(buildWaypointPopup(record));
      if (openPopup) marker.openPopup();
      marker.wayPointType = record.type;
      marker.customName = record.name || "";
      marker.windArrow = windArrow;

      marker.on("dragend", () => {
        const next = marker.getLatLng();
        record.lat = next.lat;
        record.lng = next.lng;
        windArrow.setLatLng(next);
        marker.setPopupContent(buildWaypointPopup(record));
        queueSyncSave();
      });

      marker.on("contextmenu", () => removeWaypointById(record.id));
      windArrow.on("contextmenu", () => removeWaypointById(record.id));
      windArrow.on("click", () => marker.openPopup());

      waypointVisualsById.set(record.id, { marker, windArrow });
    }

    function renderAllWaypoints() {
      waypointLayer.clearLayers();
      waypointVisualsById.clear();
      waypointRecords.forEach(record => addWaypointRecord(record, false));
    }

    function renderSavedTracks() {
      savedTrackLayers.forEach(layer => map.removeLayer(layer));
      savedTrackLayers = [];
      savedTracks.forEach(track => {
        const polyline = L.polyline(track.points, { color: "yellow", weight: 3, opacity: 0.7 }).addTo(map);
        savedTrackLayers.push(polyline);
      });
    }

    // Show waypoint creation modal
    function showWaypointModal(latlng) {
      const typeOptions = Object.entries(waypointTypes)
        .map(([key, data]) => `<option value="${key}">${data.label}</option>`)
        .join('');

      const modal = document.getElementById('modalBackdrop');
      const modalContent = document.querySelector('#modalBackdrop .modal');
      
      modalContent.innerHTML = `
        <h3>New Waypoint</h3>
        <label style="display: block; margin: 8px 0 4px 0; font-size: 13px; color: var(--muted);">Name (optional)</label>
        <input type="text" id="waypointNameInput" placeholder="e.g., East Treestand" style="width: 100%; padding: 8px; margin-bottom: 10px; border-radius: 4px; border: 1px solid var(--border); background: var(--panel); color: var(--text); box-sizing: border-box;">
        
        <label style="display: block; margin: 8px 0 4px 0; font-size: 13px; color: var(--muted);">Type</label>
        <select id="waypointTypeSelect" style="width: 100%; padding: 8px; margin-bottom: 10px; border-radius: 4px; border: 1px solid var(--border); background: var(--panel); color: var(--text); box-sizing: border-box;">
          ${typeOptions}
        </select>
        <div class="modal-buttons">
          <button class="modal-btn secondary" onclick="document.getElementById('modalBackdrop').style.display = 'none'">Cancel</button>
          <button class="modal-btn primary" id="confirmWaypointBtn">Place</button>
        </div>
      `;
      
      modal.style.display = 'flex';
      
      // Focus on name input
      setTimeout(() => document.getElementById('waypointNameInput').focus(), 100);
      
      document.getElementById('confirmWaypointBtn').addEventListener('click', async () => {
        // Auto-fetch weather if wind data not loaded yet
        if (currentWind.speed === 0 && !lastWeatherData) {
          try {
            await fetchWeather();
          } catch (err) {
            console.warn("Could not fetch weather for waypoint", err);
          }
        }
        
        const type = document.getElementById('waypointTypeSelect').value;
        const customName = document.getElementById('waypointNameInput').value.trim();
        const waypoint = {
          id: crypto.randomUUID(),
          lat: latlng.lat,
          lng: latlng.lng,
          type,
          name: customName,
          createdAt: new Date().toISOString()
        };

        waypointRecords.push(waypoint);
        addWaypointRecord(waypoint, true);
        queueSyncSave();
        
        modal.style.display = 'none';
      });
    }

    // Desktop waypoint placement uses robust click-pair detection below.

    let lastMapClickAt = 0;
    let lastMapClickPoint = null;
    const mapContainer = map.getContainer();

    mapContainer.addEventListener('click', (evt) => {
      if (measuring) return;

      const target = evt.target;
      if (!target) return;
      if (target.closest && (
        target.closest('#drawer') ||
        target.closest('#drawerToggle') ||
        target.closest('.leaflet-control') ||
        target.closest('.leaflet-popup') ||
        target.closest('#accountModalBackdrop') ||
        target.closest('#modalBackdrop')
      )) {
        return;
      }

      if (placingWaypoint) {
        evt.preventDefault();
        evt.stopPropagation();
        const latlng = map.mouseEventToLatLng(evt);
        setWaypointPlacementMode(false);
        showWaypointModal(latlng);
        return;
      }

      const now = Date.now();
      const point = map.mouseEventToContainerPoint(evt);
      const isQuickSecondClick = now - lastMapClickAt < 350;
      const isNearPrevious = lastMapClickPoint && point.distanceTo(lastMapClickPoint) < 18;

      if (isQuickSecondClick && isNearPrevious) {
        const latlng = map.mouseEventToLatLng(evt);
        setWaypointPlacementMode(false);
        showWaypointModal(latlng);
        lastMapClickAt = 0;
        lastMapClickPoint = null;
        return;
      }

      lastMapClickAt = now;
      lastMapClickPoint = point;
    }, true);

    // Long-press to place waypoint (mobile)
    let longPressTimer = null;
    let longPressTriggered = false;

    map.on('mousedown', (e) => {
      longPressTriggered = false;
      longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        showWaypointModal(e.latlng);
      }, 800); // 800ms long press
    });

    map.on('mouseup', () => {
      clearTimeout(longPressTimer);
    });

    map.on('mousemove', () => {
      clearTimeout(longPressTimer);
    });

    // Keep the button for manual mode (optional)
    addWaypointBtn.addEventListener("click", () => {
      setWaypointPlacementMode(!placingWaypoint);
    });

    const startTrackBtn = document.getElementById("startTrackBtn");
    let tracking = false;
    let trackPolyline = null;
    let trackPoints = [];

    startTrackBtn.addEventListener("click", () => {
      const willStart = !tracking;

      if (!willStart && tracking) {
        if (trackPoints.length > 1) {
          savedTracks.push({
            id: crypto.randomUUID(),
            name: `Track ${savedTracks.length + 1}`,
            points: trackPoints.map(p => [p[0], p[1]]),
            createdAt: new Date().toISOString()
          });
          renderSavedTracks();
          queueSyncSave();
        }
        if (trackPolyline) {
          map.removeLayer(trackPolyline);
          trackPolyline = null;
        }
      }

      tracking = willStart;
      startTrackBtn.classList.toggle("active", tracking);
      if (willStart) {
        trackPoints = [];
        if (trackPolyline) map.removeLayer(trackPolyline);
        trackPolyline = L.polyline([], { color: "yellow" }).addTo(map);
      }
    });

    setInterval(() => {
      if (tracking && currentPosition) {
        trackPoints.push(currentPosition);
        if (trackPolyline) trackPolyline.setLatLngs(trackPoints);
      }
    }, 3000);

    initializeAuthFromToken();

    // Measurement tool
    const measureBtn = document.getElementById("measureBtn");
    let measuring = false;
    let measurePoints = [];
    let measureLine = null;
    const measureMarkers = [];

    function calculateDistance(lat1, lng1, lat2, lng2) {
      // Haversine formula to calculate distance in meters
      const R = 6371000; // Earth's radius in meters
      const phi1 = (lat1 * Math.PI) / 180;
      const phi2 = (lat2 * Math.PI) / 180;
      const deltaLat = ((lat2 - lat1) * Math.PI) / 180;
      const deltaLng = ((lng2 - lng1) * Math.PI) / 180;
      
      const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(phi1) * Math.cos(phi2) * 
                Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function onMapClickForMeasure(e) {
      if (!measuring) return;
      
      measurePoints.push(e.latlng);
      
      // Add marker for the clicked point
      const marker = L.circleMarker(e.latlng, {
        radius: 6,
        fillColor: "#c8ad3c",
        color: "#111111",
        weight: 2,
        opacity: 1,
        fillOpacity: 0.8
      }).addTo(map);
      measureMarkers.push(marker);
      
      if (measurePoints.length === 2) {
        // Calculate distance
        const distance = calculateDistance(
          measurePoints[0].lat, measurePoints[0].lng,
          measurePoints[1].lat, measurePoints[1].lng
        );
        
        // Draw line between points
        measureLine = L.polyline(measurePoints, {
          color: "#c8ad3c",
          weight: 2,
          opacity: 0.7,
          dashArray: "5, 5"
        }).addTo(map);
        
        // Show distance popup
        const meters = distance.toFixed(0);
        const km = (distance / 1000).toFixed(2);
        const ft = (distance * 3.28084).toFixed(0);
        
        L.popup()
          .setLatLng(measurePoints[1])
          .setContent(`<strong>Distance</strong><br>${meters}m<br>${km}km<br>${ft}ft`)
          .openOn(map);
        
        // Reset measuring
        measuring = false;
        measureBtn.classList.remove("active");
        measureBtn.textContent = "Measure Distance";
        map.off('click', onMapClickForMeasure);
      }
    }

    measureBtn.addEventListener("click", () => {
      measuring = !measuring;
      measureBtn.classList.toggle("active", measuring);
      
      if (measuring) {
        measureBtn.textContent = "Click 2 points...";
        measurePoints = [];
        measureMarkers.forEach(m => map.removeLayer(m));
        measureMarkers.length = 0;
        if (measureLine) map.removeLayer(measureLine);
        measureLine = null;
        map.on('click', onMapClickForMeasure);
      } else {
        measuring = false;
        measureBtn.textContent = "Measure Distance";
        map.off('click', onMapClickForMeasure);
        measureMarkers.forEach(m => map.removeLayer(m));
        measureMarkers.length = 0;
        if (measureLine) map.removeLayer(measureLine);
        measureLine = null;
        measurePoints = [];
      }
    });

    // Routing (simple)
    const routingBtn = document.getElementById("routingBtn");
    const clearRoutesBtn = document.getElementById("clearRoutesBtn");
    let routingControl = null;

    routingBtn.addEventListener("click", () => {
      if (!currentPosition) { alert("No GPS fix yet."); return; }
      if (routingControl) { alert("Routing already active. Clear routes first."); return; }

      routingControl = L.Routing.control({
        waypoints: [
          L.latLng(currentPosition[0], currentPosition[1]),
          L.latLng(currentPosition[0] + 0.01, currentPosition[1] + 0.01)
        ],
        routeWhileDragging: true,
        show: false
      }).addTo(map);
    });

    clearRoutesBtn.addEventListener("click", () => {
      if (routingControl) { map.removeControl(routingControl); routingControl = null; }
      if (trackPolyline) { map.removeLayer(trackPolyline); trackPolyline = null; }
      savedTrackLayers.forEach(layer => map.removeLayer(layer));
      savedTrackLayers = [];
      savedTracks = [];
      tracking = false;
      startTrackBtn.classList.remove("active");
      trackPoints = [];
      queueSyncSave();
    });

    // Activity Forecast based on real weather
    const activityForecastBtn = document.getElementById("activityForecastBtn");
    const activityModal = document.getElementById("activityModal");
    const activityPanelClose = document.getElementById("activityPanelClose");
    const activityContent = document.getElementById("activityContent");

    function generateActivityForecast() {
      if (!lastWeatherData) {
        return null; // Weather data not fetched yet
      }

      const now = new Date();
      const h = now.getHours();
      const m = now.getMonth() + 1;
      const temp = lastWeatherData.temperature_2m;
      const humidity = lastWeatherData.relative_humidity_2m;
      const windSpeed = currentWind.speed;
      const pressure = lastWeatherData.pressure_msl / 100; // Convert to mb
      const condition = getWeatherDescription(lastWeatherData.weather_code);

      // Calculate scores
      let timeScore = 0.3;
      let timeNote = "";
      if (h >= 5 && h <= 8) { timeScore = 1.0; timeNote = "Peak dawn activity"; }
      else if (h >= 15 && h <= 17) { timeScore = 0.95; timeNote = "Peak pre-rut activity"; }
      else if (h >= 17 && h <= 19) { timeScore = 0.85; timeNote = "Transition to evening activity"; }
      else if (h >= 19 && h <= 21) { timeScore = 0.7; timeNote = "Late evening movement"; }
      else if (h >= 21 && h <= 23) { timeScore = 0.4; timeNote = "Settling in for night"; }
      else if (h >= 0 && h <= 4) { timeScore = 0.2; timeNote = "Bedded down period"; }
      else if (h >= 9 && h <= 14) { timeScore = 0.25; timeNote = "Midday rest period"; }

      let seasonScore = 0.5;
      let seasonNote = "";
      if (m === 11) { seasonScore = 1.0; seasonNote = "Peak pre-rut (excellent)"; }
      else if (m === 10 || m === 12) { seasonScore = 0.95; seasonNote = "Rut in full swing"; }
      else if ((m >= 8 && m <= 9) || m === 1) { seasonScore = 0.7; seasonNote = "Good hunting season"; }
      else if (m >= 2 && m <= 7) { seasonScore = 0.3; seasonNote = "Off-season (very low activity)"; }

      let tempScore = 0.6;
      let tempNote = "";
      if (temp <= 4) { tempScore = 0.95; tempNote = "Cold temps = active feeding"; }
      else if (temp <= 10) { tempScore = 0.85; tempNote = "Cool weather boosts activity"; }
      else if (temp <= 16) { tempScore = 0.7; tempNote = "Moderate conditions"; }
      else if (temp <= 22) { tempScore = 0.5; tempNote = "Warm temps reduce activity"; }
      else { tempScore = 0.3; tempNote = "High temps = minimal movement"; }

      let windScore = 0.7;
      let windNote = "";
      if (windSpeed < 3) { windScore = 0.6; windNote = "Very calm (deer wary)"; }
      else if (windSpeed < 8) { windScore = 1.0; windNote = "Ideal hunting wind"; }
      else if (windSpeed < 15) { windScore = 0.8; windNote = "Moderate wind OK"; }
      else { windScore = 0.5; windNote = "Strong wind = hunkered down"; }

      let humidityScore = 0.7;
      let humidityNote = "";
      if (humidity < 40) { humidityScore = 0.6; humidityNote = "Dry air (less active)"; }
      else if (humidity < 70) { humidityScore = 0.85; humidityNote = "Ideal conditions"; }
      else { humidityScore = 0.75; humidityNote = "High humidity OK"; }

      let pressureScore = 0.7;
      let pressureNote = "";
      if (pressure > 1025) { pressureScore = 0.85; pressureNote = "High pressure = active"; }
      else if (pressure > 1013) { pressureScore = 0.9; pressureNote = "Excellent pressure"; }
      else { pressureScore = 0.65; pressureNote = "Low pressure = sluggish"; }

      // Weighted overall score
      const overall = (timeScore * 0.25 + seasonScore * 0.25 + tempScore * 0.15 + windScore * 0.15 + humidityScore * 0.1 + pressureScore * 0.1);

      let forecastLevel = "Poor";
      let forecastColor = "#dc2626";
      let forecastDesc = "Minimal deer movement expected";
      let tips = "Focus on bedding areas and food sources";

      if (overall >= 0.85) {
        forecastLevel = "Excellent";
        forecastColor = "#16a34a";
        forecastDesc = "Peak hunting conditions - deer are actively moving";
        tips = "Position yourself in travel corridors and food sources. Great day to be in the field.";
      } else if (overall >= 0.75) {
        forecastLevel = "Very Good";
        forecastColor = "#84cc16";
        forecastDesc = "Strong deer activity expected";
        tips = "Hunt productive areas with good scent control and patience.";
      } else if (overall >= 0.65) {
        forecastLevel = "Good";
        forecastColor = "#eab308";
        forecastDesc = "Decent hunting potential";
        tips = "Focus on prime feeding and bedding transitions. Hunt with purpose.";
      } else if (overall >= 0.50) {
        forecastLevel = "Fair";
        forecastColor = "#f59e0b";
        forecastDesc = "Moderate activity - be patient";
        tips = "Hunt near water sources and food. Persistence may pay off in prime times.";
      } else if (overall >= 0.35) {
        forecastLevel = "Poor";
        forecastColor = "#ef4444";
        forecastDesc = "Low activity - challenging conditions";
        tips = "Hunt near natural food sources or bedding areas. Wait for prime hours.";
      }

      return {
        overall,
        forecastLevel,
        forecastColor,
        forecastDesc,
        tips,
        timeScore, timeNote,
        seasonScore, seasonNote,
        tempScore, tempNote, tempF: (lastWeatherData.temperature_2m * 9/5 + 32).toFixed(1),
        windScore, windNote, windSpeed: currentWind.speed,
        humidityScore, humidityNote, humidity,
        pressureScore, pressureNote, pressureInHg: (lastWeatherData.pressure_msl / 3386.39)
      };
    }

    function displayActivityForecast() {
      const forecast = generateActivityForecast();
      
      if (!forecast) {
        activityContent.innerHTML = '<div style="text-align: center; color: var(--muted);">Unable to generate forecast - weather data unavailable</div>';
        return;
      }

      activityContent.innerHTML = `
        <div class="forecast-section">
          <h4>Overall Forecast</h4>
          <div class="activity-level" style="color: ${forecast.forecastColor};">${forecast.forecastLevel}</div>
          <p style="margin: 8px 0; font-size: 13px;">${forecast.forecastDesc}</p>
        </div>
        <div class="forecast-section">
          <h4>Contributing Factors</h4>
          <div class="forecast-item">
            <p><strong>Time of Day:</strong> ${forecast.timeNote}</p>
          </div>
          <div class="forecast-item">
            <p><strong>Season:</strong> ${forecast.seasonNote}</p>
          </div>
          <div class="forecast-item">
            <p><strong>Temperature:</strong> ${forecast.tempNote} (${forecast.tempF}Â°F)</p>
          </div>
          <div class="forecast-item">
            <p><strong>Wind:</strong> ${forecast.windNote} (${(forecast.windSpeed * 0.621371).toFixed(1)} mph)</p>
          </div>
          <div class="forecast-item">
            <p><strong>Humidity:</strong> ${forecast.humidityNote} (${forecast.humidity}%)</p>
          </div>
          <div class="forecast-item">
            <p><strong>Pressure:</strong> ${forecast.pressureNote} (${forecast.pressureInHg.toFixed(2)} inHg)</p>
          </div>
        </div>
        <div class="forecast-section">
          <h4>Hunter's Tips</h4>
          <p class="tip">${forecast.tips}</p>
        </div>
      `;
    }

    activityForecastBtn.addEventListener("click", async () => {
      activityModal.classList.add("open");
      
      // Auto-fetch weather if not already loaded
      if (!lastWeatherData) {
        activityContent.innerHTML = '<div style="text-align: center; color: var(--muted); padding: 20px;">Fetching weather data...</div>';
        await fetchWeather();
      }
      
      displayActivityForecast();
    });

    activityPanelClose.addEventListener("click", () => {
      activityModal.classList.remove("open");
    });

    // Close modal when clicking outside
    activityModal.addEventListener("click", (e) => {
      if (e.target === activityModal) {
        activityModal.classList.remove("open");
      }
    });

    // Heatmap toggle placeholder (deprecated, replaced with activity forecast)
    // Kept for reference only

    // Stealth mode
    const stealthModeBtn = document.getElementById("stealthModeBtn");
    const reportProblemBtn = document.getElementById("reportProblemBtn");
    const reportProblemModal = document.getElementById("reportProblemModal");
    const reportContactEmail = document.getElementById("reportContactEmail");
    const reportMessage = document.getElementById("reportMessage");
    const cancelReportBtn = document.getElementById("cancelReportBtn");
    const submitReportBtn = document.getElementById("submitReportBtn");
    let stealthMode = false;

    stealthModeBtn.addEventListener("click", () => {
      stealthMode = !stealthMode;
      stealthModeBtn.classList.toggle("active", stealthMode);
      document.getElementById("map").style.filter = stealthMode ? "brightness(0.4)" : "brightness(1)";
    });

    reportProblemBtn.addEventListener("click", () => {
      reportProblemModal.style.display = "flex";
      setTimeout(() => reportMessage.focus(), 50);
    });

    cancelReportBtn.addEventListener("click", () => {
      reportProblemModal.style.display = "none";
    });

    reportProblemModal.addEventListener("click", (e) => {
      if (e.target === reportProblemModal) {
        reportProblemModal.style.display = "none";
      }
    });

    submitReportBtn.addEventListener("click", async () => {
      const message = reportMessage.value.trim();
      const contactEmail = reportContactEmail.value.trim();

      if (message.length < 5) {
        alert("Please describe the problem with a little more detail.");
        return;
      }

      submitReportBtn.disabled = true;
      submitReportBtn.textContent = "Submitting...";

      try {
        const response = await fetch("/api/feedback", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            message,
            contactEmail,
            pageUrl: window.location.href,
            userAgent: navigator.userAgent
          })
        });

        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(payload.error || `Request failed: ${response.status}`);
        }

        alert("Thanks â€” your report was submitted.");
        reportMessage.value = "";
        reportContactEmail.value = "";
        reportProblemModal.style.display = "none";
      } catch (err) {
        alert(`Could not submit report: ${err.message}`);
      } finally {
        submitReportBtn.disabled = false;
        submitReportBtn.textContent = "Submit";
      }
    });

    // =========================================================
    // âœ… FIXED AREA STATUS + ARCHERY HATCH + CAN DOTS (ONLY)
    // =========================================================
    const refreshStatusBtn = document.getElementById("refreshStatusBtn");
    const statusSummary = document.getElementById("statusSummary");
    const statusCounts = document.getElementById("statusCounts");

    let flwAreasLayer = null;
    let archeryLayerGroup = null;
    let cantonmentLayerGroup = null;

    function getCheckedInCount(statusObj) {
      if (!statusObj) return 0;
      if (typeof statusObj.OccupancyUsed === "number") return statusObj.OccupancyUsed;

      const obt = statusObj.OccupanciesByOccupancyType;
      if (obt && typeof obt === "object") {
        let sum = 0;
        let found = false;
        for (const k of Object.keys(obt)) {
          const v = obt[k];
          if (typeof v === "number") { sum += v; found = true; continue; }
          if (v && typeof v === "object") {
            for (const c of ["Count","count","Used","used","OccupancyUsed","occupancyUsed"]) {
              if (typeof v[c] === "number") { sum += v[c]; found = true; break; }
            }
          }
        }
        if (found) return sum;
      }
      return 0;
    }

    async function fetchAreaStatus() {
      try {
        statusSummary.textContent = "Status: loadingâ€¦";
        const r = await fetch("/api/areas", { cache: "no-store" });
        
        if (!r.ok) {
          statusSummary.textContent = "Status: error " + r.status;
          return;
        }

        const json = await r.json();
        
        const data = json.data || [];

        let openCount = 0;
        let closedCount = 0;
        let signedInTotal = 0;

        const statusBySyskey = new Map();
        
        for (const a of data) {
          const key = Number(a.Area_Syskey);
          statusBySyskey.set(key, a);

          if (a.Open === true) openCount++;
          if (a.Open === false) closedCount++;
          signedInTotal += getCheckedInCount(a);
        }
        
        statusSummary.textContent = `Status: ${openCount} open, ${closedCount} closed.`;
        statusCounts.textContent = `Open: ${openCount}, Closed: ${closedCount}, Signed in: ${signedInTotal}`;

        await renderFLWAreas(statusBySyskey);
      } catch (e) {
        console.error("Error in fetchAreaStatus:", e);
        statusSummary.textContent = "Status: error fetching data.";
      }
    }

    async function renderFLWAreas(statusBySyskey) {
      try {
        if (flwAreasLayer) { map.removeLayer(flwAreasLayer); flwAreasLayer = null; }
        if (archeryLayerGroup) { map.removeLayer(archeryLayerGroup); archeryLayerGroup = null; }
        if (cantonmentLayerGroup) { map.removeLayer(cantonmentLayerGroup); cantonmentLayerGroup = null; }

        const r = await fetch("flw_areas.geojson", { cache: "no-store" });
        
        const gj = await r.json();
        areaFeatures = gj.features;

        // Patterns
        const archeryHatch = new L.StripePattern({
          weight: 3,
          spaceWeight: 6,
          color: "#f97316",
          opacity: 0.50,
          angle: 45
        });
        archeryHatch.addTo(map);

        const canDots = new L.Pattern({ width: 10, height: 10 });
        const dot = new L.PatternCircle({
          x: 5, y: 5,
          radius: 2,
          fill: true,
          fillColor: "#3b82f6",
          fillOpacity: 0.85,
          stroke: false
        });
        canDots.addShape(dot);
        canDots.addTo(map);

        let currentAreaOpacity = 0.35;

        function styleFeature(feature) {
          const syskey = Number(feature?.properties?.area_syskey);
          const status = statusBySyskey.get(syskey);

          let fillColor = "#6b7280";
          if (status?.Open === true) fillColor = "#16a34a";
          if (status?.Open === false) fillColor = "#dc2626";

          return { color: "#111827", weight: 1, fillColor, fillOpacity: currentAreaOpacity };
        }

        function onEachFeature(feature, layer) {
          const syskey = Number(feature?.properties?.area_syskey);
          const status = statusBySyskey.get(syskey);

          const name = feature?.properties?.area_name || "Area";
          const typeRaw = feature?.properties?.area_type || "";
          const type = String(typeRaw).trim();
          const typeLower = type.toLowerCase();
          const displayType = (typeLower.includes("archery") || typeLower.includes("can") || typeLower.includes("cantonment"))
            ? type
            : "HA";
          const openText = status ? (status.Open ? "OPEN" : "CLOSED") : "UNKNOWN";
          const signedIn = getCheckedInCount(status);

          layer.bindPopup(
            `<strong>${name}</strong><br>` +
            `Type: ${displayType}<br>` +
            `Status: ${openText}<br>` +
            `Signed in: ${signedIn}<br>` +
            `<button style="width: 100%; margin-top: 8px; padding: 6px; background: var(--gold); color: #111111; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;" onclick="window.open('https://ftleonardwood.isportsman.net/Login.aspx', '_blank')">SIGN IN</button>`
          );

          const bindToolInteractions = (targetLayer) => {
            targetLayer.on("click", (e) => {
              if (placingWaypoint) {
                L.DomEvent.stop(e);
                setWaypointPlacementMode(false);
                showWaypointModal(e.latlng);
                return;
              }

              if (measuring) {
                L.DomEvent.stop(e);
                onMapClickForMeasure(e);
                return;
              }

              const clickCount = Number(e?.originalEvent?.detail || 0);
              if (clickCount >= 2) {
                L.DomEvent.stop(e);
                showWaypointModal(e.latlng);
              }
            });

            targetLayer.on("dblclick", (e) => {
              L.DomEvent.stop(e);
              showWaypointModal(e.latlng);
            });
          };

          bindToolInteractions(layer);

          layer.on("mouseover", () => layer.setStyle({ weight: 2, color: "#fbbf24" }));
          layer.on("mouseout", () => layer.setStyle(styleFeature(feature)));

          layer.bindToolInteractions = bindToolInteractions;
        }

        flwAreasLayer = L.geoJSON(gj, { style: styleFeature, onEachFeature }).addTo(map);
        
        // Update area opacity based on zoom level
        function updateAreaOpacity() {
          if (!flwAreasLayer) return;
          const zoom = map.getZoom();
          // Fade out later as you zoom in: max opacity at zoom 12, fade to near 0 by zoom 17
          currentAreaOpacity = Math.max(0.02, 0.35 * Math.pow(0.78, zoom - 12));
          flwAreasLayer.setStyle({ fillOpacity: currentAreaOpacity });

          if (archeryLayerGroup) {
            archeryLayerGroup.eachLayer(layer => {
              layer.setStyle({ fillOpacity: currentAreaOpacity, opacity: currentAreaOpacity });
            });
          }

          if (cantonmentLayerGroup) {
            cantonmentLayerGroup.eachLayer(layer => {
              layer.setStyle({ fillOpacity: currentAreaOpacity, opacity: currentAreaOpacity });
            });
          }
        }
        
        map.on('zoomend', updateAreaOpacity);
        updateAreaOpacity();
        
        // Auto-fit map to show all areas
        if (flwAreasLayer && flwAreasLayer.getLayers().length > 0) {
          const bounds = flwAreasLayer.getBounds();
          if (bounds.isValid()) {
            map.fitBounds(bounds, { padding: [50, 50] });
          }
        }

        // Pattern overlays for Archery + CAN
        const archeryPolys = [];
        const cantonmentPolys = [];

        flwAreasLayer.eachLayer(layer => {
          const f = layer.feature;
          if (!f || !f.properties) return;
          const t = String(f.properties.area_type || "").trim().toLowerCase();

          // Get popup content from the original feature
          const syskey = Number(f?.properties?.area_syskey);
          const status = statusBySyskey.get(syskey);
          const name = f?.properties?.area_name || "Area";
          const typeRaw = f?.properties?.area_type || "";
          const typeText = String(typeRaw).trim();
          const typeLower = typeText.toLowerCase();
          const displayType = (typeLower.includes("archery") || typeLower.includes("can") || typeLower.includes("cantonment"))
            ? typeText
            : "HA";
          const openText = status ? (status.Open ? "OPEN" : "CLOSED") : "UNKNOWN";
          const signedIn = getCheckedInCount(status);
          const popupContent = 
            `<strong>${name}</strong><br>` +
            `Type: ${displayType}<br>` +
            `Status: ${openText}<br>` +
            `Signed in: ${signedIn}`;

          if (t === "archery" || t.includes("archery")) {
            const poly = L.polygon(layer.getLatLngs(), {
              color: "transparent",
              weight: 0,
              fillOpacity: currentAreaOpacity,
              fillPattern: archeryHatch
            });
            poly.bindPopup(popupContent);
            if (typeof layer.bindToolInteractions === "function") {
              layer.bindToolInteractions(poly);
            }
            poly.on("mouseover", () => poly.setStyle({ weight: 2, color: "#fbbf24" }));
            poly.on("mouseout", () => poly.setStyle({ weight: 0, color: "transparent" }));
            archeryPolys.push(poly);
          }

          if (t === "can" || t.includes("cantonment")) {
            const poly = L.polygon(layer.getLatLngs(), {
              color: "transparent",
              weight: 0,
              fillOpacity: currentAreaOpacity,
              fillPattern: canDots
            });
            poly.bindPopup(popupContent);
            if (typeof layer.bindToolInteractions === "function") {
              layer.bindToolInteractions(poly);
            }
            poly.on("mouseover", () => poly.setStyle({ weight: 2, color: "#fbbf24" }));
            poly.on("mouseout", () => poly.setStyle({ weight: 0, color: "transparent" }));
            cantonmentPolys.push(poly);
          }
        });

        if (archeryPolys.length) archeryLayerGroup = L.layerGroup(archeryPolys).addTo(map);
        if (cantonmentPolys.length) cantonmentLayerGroup = L.layerGroup(cantonmentPolys).addTo(map);

        updateAreaOpacity();
        
      } catch (e) {
        console.error("Error in renderFLWAreas:", e);
        statusSummary.textContent = "Status: error rendering areas.";
      }
    }

    refreshStatusBtn.addEventListener("click", fetchAreaStatus);
    fetchAreaStatus();

    // -----------------------------
    // Offline Maps: IndexedDB helpers
    // -----------------------------
    const offlineStorageUsage = document.getElementById("offlineStorageUsage");
    const includeSatelliteToggle = document.getElementById("includeSatelliteToggle");
    const offlineZoomSelect = document.getElementById("offlineZoomSelect");
    const downloadOfflineBtn = document.getElementById("downloadOfflineBtn");
    const manageOfflineBtn = document.getElementById("manageOfflineBtn");
    const offlineIndicator = document.getElementById("offlineIndicator");

    const DB_NAME = "huntbase_offline_tiles";
    const DB_VERSION = 1;
    const TILE_STORE = "tiles";
    const PACK_STORE = "packs";
    const MAX_STORAGE_BYTES = 5 * 1024 * 1024 * 1024; // ~5GB

    let dbPromise = null;

    function openDB() {
      if (dbPromise) return dbPromise;
      dbPromise = new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = e => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(TILE_STORE)) {
            const store = db.createObjectStore(TILE_STORE, { keyPath: "id" });
            store.createIndex("byPack", "packId", { unique: false });
          }
          if (!db.objectStoreNames.contains(PACK_STORE)) {
            db.createObjectStore(PACK_STORE, { keyPath: "id" });
          }
        };
        req.onsuccess = e => resolve(e.target.result);
        req.onerror = e => reject(e.target.error);
      });
      return dbPromise;
    }

    async function estimateStorageUsage() {
      if (!navigator.storage || !navigator.storage.estimate) {
        offlineStorageUsage.textContent = "Storage Used: unknown";
        return;
      }
      const { usage, quota } = await navigator.storage.estimate();
      const usedMB = usage ? (usage / (1024 * 1024)).toFixed(1) : "?";
      const quotaMB = quota ? (quota / (1024 * 1024)).toFixed(0) : "?";
      offlineStorageUsage.textContent = `Storage Used: ${usedMB} MB of ~${quotaMB} MB`;
    }
    estimateStorageUsage();

    async function saveTile(packId, layerType, z, x, y, blob) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(TILE_STORE, "readwrite");
        const store = tx.objectStore(TILE_STORE);
        const id = `${packId}_${layerType}_${z}_${x}_${y}`;
        store.put({ id, packId, layerType, z, x, y, data: blob });
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e.target.error);
      });
    }

    async function getTile(layerType, z, x, y) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(TILE_STORE, "readonly");
        const store = tx.objectStore(TILE_STORE);
        const req = store.openCursor();
        let found = null;
        const suffix = `_${layerType}_${z}_${x}_${y}`;
        req.onsuccess = e => {
          const cursor = e.target.result;
          if (!cursor) {
            resolve(found);
            return;
          }
          if (cursor.key.endsWith(suffix)) {
            found = cursor.value;
            resolve(found);
            return;
          }
          cursor.continue();
        };
        req.onerror = e => reject(e.target.error);
      });
    }

    async function savePack(pack) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(PACK_STORE, "readwrite");
        const store = tx.objectStore(PACK_STORE);
        store.put(pack);
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e.target.error);
      });
    }

    async function getAllPacks() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(PACK_STORE, "readonly");
        const store = tx.objectStore(PACK_STORE);
        const req = store.getAll();
        req.onsuccess = e => resolve(e.target.result || []);
        req.onerror = e => reject(e.target.error);
      });
    }

    async function deletePack(packId) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx1 = db.transaction(TILE_STORE, "readwrite");
        const store1 = tx1.objectStore(TILE_STORE);
        const idx = store1.index("byPack");
        const range = IDBKeyRange.only(packId);
        const req = idx.openCursor(range);
        req.onsuccess = e => {
          const cursor = e.target.result;
          if (cursor) {
            cursor.delete();
            cursor.continue();
          }
        };
        tx1.oncomplete = () => {
          const tx2 = db.transaction(PACK_STORE, "readwrite");
          const store2 = tx2.objectStore(PACK_STORE);
          store2.delete(packId);
          tx2.oncomplete = () => resolve();
          tx2.onerror = e => reject(e.target.error);
        };
        tx1.onerror = e => reject(e.target.error);
      });
    }

    async function getAllTiles() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(TILE_STORE, "readonly");
        const store = tx.objectStore(TILE_STORE);
        const req = store.getAll();
        req.onsuccess = e => resolve(e.target.result || []);
        req.onerror = e => reject(e.target.error);
      });
    }

    // Offline download and manage button handlers
    downloadOfflineBtn.addEventListener("click", () => {
      document.getElementById("offlineDownloadModal").style.display = "flex";
    });

    manageOfflineBtn.addEventListener("click", async () => {
      document.getElementById("offlineManageModal").style.display = "flex";
      await loadAndDisplayPacks();
    });

    document.getElementById("offlineDownloadModal").addEventListener("click", (e) => {
      if (e.target.id === "offlineDownloadModal") {
        document.getElementById("offlineDownloadModal").style.display = "none";
      }
    });

    document.getElementById("offlineManageModal").addEventListener("click", (e) => {
      if (e.target.id === "offlineManageModal") {
        document.getElementById("offlineManageModal").style.display = "none";
      }
    });

    async function performOfflineDownload() {
      const zoomLevel = parseInt(document.getElementById("offlineZoomLevelSelect").value);
      const bounds = map.getBounds();
      const north = bounds.getNorth();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const west = bounds.getWest();

      const progressDiv = document.getElementById("downloadProgress");
      const progressBar = document.getElementById("downloadProgressBar");
      const progressStatus = document.getElementById("downloadStatus");
      const startBtn = document.getElementById("startDownloadBtn");

      progressDiv.style.display = "block";
      startBtn.disabled = true;

      try {
        // Get tile coordinates for the bounds at this zoom level
        const tilesNeeded = calculateTilesForBounds(north, south, east, west, zoomLevel);
        let tilesDownloaded = 0;
        let tilesAttempted = 0;
        const packId = `offline-pack-${Date.now()}`;
        const packName = `Offline Pack ${new Date().toLocaleString()}`;

        for (const { x, y } of tilesNeeded) {
          const url = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoomLevel}/${y}/${x}`;
          
          try {
            const response = await fetch(url);
            if (response.ok) {
              const blob = await response.blob();
              await saveTile(packId, "satellite", zoomLevel, x, y, blob);
              tilesDownloaded++;
            }
          } catch (e) {
            console.warn(`Failed to download tile ${zoomLevel}/${x}/${y}:`, e);
          }

          tilesAttempted++;
          progressStatus.textContent = `${tilesAttempted}/${tilesNeeded.length}`;
          progressBar.style.width = `${(tilesAttempted / tilesNeeded.length) * 100}%`;
        }

        if (tilesDownloaded > 0) {
          await savePack({
            id: packId,
            name: packName,
            zoom: zoomLevel,
            downloadDate: new Date().toISOString(),
            bounds: { north, south, east, west },
            tileCount: tilesDownloaded
          });
        }

        alert(`Download complete! ${tilesDownloaded} tiles saved.`);
        progressDiv.style.display = "none";
        startBtn.disabled = false;
        document.getElementById("offlineDownloadModal").style.display = "none";
        updateOfflineIndicator();
        estimateStorageUsage();
      } catch (err) {
        console.error("Download error:", err);
        alert("Download failed: " + err.message);
        progressDiv.style.display = "none";
        startBtn.disabled = false;
      }
    }

    function calculateTilesForBounds(north, south, east, west, zoom) {
      const tiles = [];
      const n = 1 << zoom;

      function latLngToTile(lat, lng) {
        const x = Math.floor(((lng + 180) / 360) * n);
        const y = Math.floor(((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2) * n);
        return { x: Math.max(0, Math.min(n - 1, x)), y: Math.max(0, Math.min(n - 1, y)) };
      }

      const nwTile = latLngToTile(north, west);
      const seTile = latLngToTile(south, east);

      for (let x = nwTile.x; x <= seTile.x; x++) {
        for (let y = nwTile.y; y <= seTile.y; y++) {
          tiles.push({ x, y });
        }
      }

      return tiles;
    }

    async function loadAndDisplayPacks() {
      try {
        const packs = await getAllPacks();
        const tiles = await getAllTiles();

        let totalSize = 0;
        tiles.forEach(tile => {
          if (tile.data && tile.data.size) totalSize += tile.data.size;
        });

        const sizeInMB = (totalSize / (1024 * 1024)).toFixed(2);
        const storagePercent = (totalSize / (5 * 1024 * 1024 * 1024)) * 100;

        document.getElementById("storageSizeDisplay").textContent = sizeInMB + " MB";
        document.getElementById("storageBar").style.width = Math.min(100, storagePercent) + "%";

        const packsList = document.getElementById("packsList");
        if (packs.length === 0) {
          packsList.innerHTML = '<p style="font-size: 12px; color: var(--muted); text-align: center; padding: 20px;">No offline packs downloaded yet</p>';
          return;
        }

        packsList.innerHTML = packs.map(pack => `
          <div style="padding: 12px; margin: 8px 0; background: rgba(0,0,0,0.3); border-radius: 4px; border-left: 3px solid var(--gold); display: flex; justify-content: space-between; align-items: center;">
            <div>
              <strong style="color: var(--gold-strong);">${pack.name}</strong><br>
              <small style="color: var(--muted);">Zoom ${pack.zoom} â€¢ ${new Date(pack.downloadDate).toLocaleDateString()}</small>
            </div>
            <button onclick="deletePack('${pack.id}').then(() => loadAndDisplayPacks())" style="background: #dc2626; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
          </div>
        `).join("");
      } catch (err) {
        console.error("Error loading packs:", err);
        document.getElementById("packsList").innerHTML = '<p style="color: #dc2626;">Error loading packs</p>';
      }
    }

    document.getElementById("startDownloadBtn").addEventListener("click", performOfflineDownload);

    // Offline tile loader
    function createOfflineTileLayer(baseLayer, layerType) {
      return L.tileLayer(baseLayer._url, {
        maxZoom: baseLayer.options.maxZoom,
        attribution: baseLayer.getAttribution(),
        tileSize: 256,
        async: true,
        crossOrigin: true
      }).on("tileloadstart", async function (event) {
        const tile = event.tile;
        const coords = event.coords;
        const z = coords.z;
        const x = coords.x;
        const y = coords.y;

        try {
          const cached = await getTile(layerType, z, x, y);
          if (cached && cached.data) {
            tile.src = URL.createObjectURL(cached.data);
            return;
          }
        } catch (e) {
          console.warn("Error reading tile cache:", e);
        }

        const src = this.getTileUrl(coords);
        fetch(src)
          .then(r => r.blob())
          .then(async blob => {
            tile.src = URL.createObjectURL(blob);
          })
          .catch(() => {});
      });
    }

    const offlineUSGS = createOfflineTileLayer(usgsTopo, "usgs");
    const offlineESRI = createOfflineTileLayer(esriTopo, "esri");
    const offlineOTM = createOfflineTileLayer(otmTopo, "otm");
    const offlineSAT = createOfflineTileLayer(satellite, "sat");

    // Offline indicator (simple)
    async function updateOfflineIndicator() {
      const packs = await getAllPacks();
      if (!packs.length) {
        offlineIndicator.style.display = "none";
        return;
      }
      const center = map.getCenter();
      const lat = center.lat;
      const lng = center.lng;
      let inside = false;
      for (const p of packs) {
        const { north, south, east, west } = p.bounds;
        if (lat <= north && lat >= south && lng >= west && lng <= east) {
          inside = true;
          break;
        }
      }
      offlineIndicator.style.display = inside ? "block" : "none";
    }

    map.on("moveend", updateOfflineIndicator);
    updateOfflineIndicator();

    // Real Weather Data from Open-Meteo API
    const weatherBtn = document.getElementById("weatherBtn");
    const weatherModal = document.getElementById("weatherModal");
    const weatherPanelClose = document.getElementById("weatherPanelClose");
    const weatherContent = document.getElementById("weatherContent");

    // Fort Leonard Wood coordinates
    const LOCATION = { lat: 38.2028, lng: -92.1735, name: "Fort Leonard Wood, MO" };

    async function fetchWeather() {
      try {
        weatherContent.innerHTML = '<div class="loading">Fetching weather data...</div>';

        const weatherLat = currentPosition ? currentPosition[0] : LOCATION.lat;
        const weatherLng = currentPosition ? currentPosition[1] : LOCATION.lng;
        const weatherLabel = currentPosition
          ? await getWeatherLocationLabel(weatherLat, weatherLng)
          : LOCATION.name;

        // Open-Meteo API (free, no key needed)
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${weatherLat}&longitude=${weatherLng}&current=temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,weather_code,wind_speed_10m,wind_direction_10m,pressure_msl&timezone=auto`;
        
        const response = await fetch(url);
        const data = await response.json();
        const current = data.current;
        
        // Store wind data globally for waypoints
        currentWind = {
          speed: current.wind_speed_10m,
          direction: current.wind_direction_10m,
          angle: current.wind_direction_10m
        };
        
        lastWeatherData = { ...current, fetchTime: new Date() };
        lastWeatherFetchAt = Date.now();
        updateWeather();
        displayWeather(current, weatherLabel);
      } catch (err) {
        console.error("Weather fetch failed:", err);
        weatherContent.innerHTML = '<div class="loading" style="color: #dc2626;">Unable to fetch weather data</div>';
      }
    }

    function getWeatherDescription(code) {
      // WMO Weather interpretation codes
      const codes = {
        0: "Clear sky",
        1: "Mainly clear",
        2: "Partly cloudy",
        3: "Overcast",
        45: "Foggy",
        48: "Foggy",
        51: "Light drizzle",
        53: "Moderate drizzle",
        55: "Dense drizzle",
        61: "Slight rain",
        63: "Moderate rain",
        65: "Heavy rain",
        71: "Slight snow",
        73: "Moderate snow",
        75: "Heavy snow",
        80: "Slight rain showers",
        81: "Moderate rain showers",
        82: "Violent rain showers",
        85: "Slight snow showers",
        86: "Heavy snow showers",
        95: "Thunderstorm",
        96: "Thunderstorm with hail",
        99: "Thunderstorm with hail"
      };
      return codes[code] || "Unknown";
    }

    function getWindDirection(angle) {
      const dirs = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
      return dirs[Math.round(angle / 22.5) % 16];
    }

    function displayWeather(current, locationLabel = LOCATION.name) {
      const tempF = (current.temperature_2m * 9/5 + 32).toFixed(1);
      const feelsLikeF = (current.apparent_temperature * 9/5 + 32).toFixed(1);
      const humidity = current.relative_humidity_2m;
      const pressureInHg = (current.pressure_msl / 3386.39).toFixed(2);
      const windSpeed = current.wind_speed_10m;
      const windAngle = current.wind_direction_10m;
      const windDir = getWindDirection(windAngle);
      const condition = getWeatherDescription(current.weather_code);
      const precipIn = (current.precipitation || 0) * 0.03937;

      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      weatherContent.innerHTML = `
        <div class="weather-section">
          <h4>Current Conditions at ${locationLabel}</h4>
          <div class="weather-item">
            <strong>Temperature:</strong>
            <span>${tempF}Â°F</span>
          </div>
          <div class="weather-item">
            <strong>Feels Like:</strong>
            <span>${feelsLikeF}Â°F</span>
          </div>
          <div class="weather-item">
            <strong>Condition:</strong>
            <span>${condition}</span>
          </div>
        </div>
        <div class="weather-section">
          <h4>Wind & Pressure</h4>
          <div class="weather-item">
            <strong>Wind Speed:</strong>
            <span>${(windSpeed * 0.621371).toFixed(1)} mph</span>
          </div>
          <div class="weather-item">
            <strong>Wind Direction:</strong>
            <span>${windDir} (${windAngle}Â°)</span>
          </div>
          <div class="weather-item">
            <strong>Pressure:</strong>
            <span>${pressureInHg} inHg</span>
          </div>
        </div>
        <div class="weather-section">
          <h4>Other</h4>
          <div class="weather-item">
            <strong>Humidity:</strong>
            <span>${humidity}%</span>
          </div>
          <div class="weather-item">
            <strong>Precipitation:</strong>
            <span>${precipIn.toFixed(2)} in</span>
          </div>
        </div>
        <div class="last-updated">Updated: ${time}<br>Data from Open-Meteo</div>
      `;
    }

    weatherBtn.addEventListener("click", () => {
      weatherModal.classList.add("open");
      fetchWeather();
    });

    weatherPanelClose.addEventListener("click", () => {
      weatherModal.classList.remove("open");
    });

    // Close modal when clicking outside
    weatherModal.addEventListener("click", (e) => {
      if (e.target === weatherModal) {
        weatherModal.classList.remove("open");
      }
    });

    // Service worker registration
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("service-worker.js").catch(err => console.warn("SW registration failed:", err));
      });
    }
  </script>
</body>
</html>